# coding: utf8
"""
Модуль предоставляет тип слова для построения AST.
Настройка пакета слов.
Слово -- кусочек текста в исходнике.
Обладает несколькими свойствами:
1. Литеры (само слово)
2. Координаты.
3. Строка, в которой он находится.
"""

from пакКомпилер.пакИсходник.модКоординаты import тКоорд

class тСлово:
	"""
	Тип тСлово описывает слово, как отдельную сущность в составе исходного
	текста, обладает различными атрибутами.
	"""
	кПусто = 0
	кМодульИмя   = кПусто + 1
	кМодульАлиас = кМодульИмя   + 1
	кЗапятая     = кМодульАлиас + 1
	кТочкаЗапятая= кЗапятая + 1
	кИмя         = кТочкаЗапятая + 1
	кКомментНачать=кИмя   + 1
	кКомментЗакончить=кКомментНачать + 1
	кОпределить  = кКомментЗакончить + 1
	кПрисвоить   = кОпределить  + 1
	кСкобкаОткрКругл=кПрисвоить + 1
	кСкобкаЗакрКругл=кСкобкаОткрКругл + 1
	кДеление     = кСкобкаЗакрКругл   + 1
	кУмножить    = кДеление + 1
	кМинус       = кУмножить+ 1
	кПлюс        = кМинус   + 1
	кЧисло       = кПлюс    + 1
	кСтрока      = кЧисло   + 1
	кСравнитьРавно=кСтрока  + 1
	кТочка       = кСравнитьРавно + 1
	запр_имя     = ["MODULE", "IMPORT", "CONST", "TYPE", "BOOLEAN", "BYTE", \
							"INTEGER", "CHAR", "SET", "REAL", "VAR", "POINTER", "TO", \
							"ARRAY", "OF", "BEGIN", "END", "PROCEDURE", "FOR", \
							"WHILE", "DO", "RECORD" ]
	def __init__(сам, пКорень, пКоорд, пстрСлово, пцНомерСлова, пРод):
		def Коорд_Проверить():
			бУсл = type(пКоорд) == тКоорд
			стрСообщ = "тСлово.__init__(): пКоорд должен быть тКоорд, type(пКоорд)="+str(type(пКоорд))
			пКорень.конс.Проверить(бУсл, стрСообщ)

		def Литеры_Проверить():
			бУсл = type(пстрСлово) == str
			стрСообщ = "тСлово.__init__(): пстрСлово должно быть строкой, type(пстрСлово)="+str(type(пстрСлово))
			пКорень.конс.Проверить(бУсл, стрСообщ)

			бУсл = len(пстрСлово) > 0
			стрСообщ = "тСлово.__init__(): пстрСлово не могут быть пустыми"
			пКорень.конс.Проверить(бУсл, стрСообщ)

		def НомерСлова_Проверить():
			бУсл = type(пцНомерСлова) == int
			стрСообщ = "тСлово.__init__(): пцНомерСлова должен быть целым, type(пцНомерСлова)="+str(type(пцНомерСлова))
			пКорень.конс.Проверить(бУсл, стрСообщ)

			бУсл = пцНомерСлова >= 0
			стрСообщ = "тСлово.__init__(): пцНомерСлова должен быть равен или больше 0, пцНомерСлова="+str(пцНомерСлова)
			пКорень.конс.Проверить(бУсл, стрСообщ)
			сам.__номер = пцНомерСлова

		сам.__корень = пКорень
		сам.__род = пРод # род слова
		сам.конс = пКорень.конс

		Коорд_Проверить()
		Литеры_Проверить()
		НомерСлова_Проверить()

		сам.коорд = тКоорд(пКорень, пКоорд.стр, пКоорд.поз)
		сам.__стрСтрока = пстрСлово

	@property
	def строка(сам):
		return сам.__стрСтрока

	@property
	def номер(сам):
		return сам.__номер

	def _Номер_Уст(сам, пцСлово):
		бУсл = type(пцСлово) == int
		стрОш = "тСлово.__init__(): пцСлово должен быть целым, type(пцСлово)="+str(type(пцСлово))
		сам.__корень.конс.Проверить(бУсл, стрОш)

		бУсл = пцСлово >= 0
		стрОш = "тСлово.__init__(): пцСлово должен быть равен или больше 0, пцСлово="+str(пцСлово)
		сам.__корень.конс.Проверить(бУсл, стрОш)

		сам.__номер = пцСлово

	def ЕслиСтр_Допустимо(сам):
		"""
		Проверяет на допустимость строки -- без специальных символов.
		"""
		бВыход = False
		if сам.__стрСтрока[0]=="_":
			бВыход = True
		elif сам.__стрСтрока[0].isalpha():
			бВыход = True
		return бВыход

	def ЕслиИмя(сам):
		'''
		Проверяет на допустимость литер в слове для обнаружения имени сущности.
		Не допускает зарезервированные слова.
		'''
		# имя сущности должно начинаться либо с "_", либо с буквы
		бВыход = False
		if сам.__стрСтрока[0]=="_":
			бВыход = True
		elif сам.__стрСтрока[0].isalpha():
			if not (сам.__стрСтрока) in тСлово.запр_имя:
				for лит in сам.__стрСтрока:
					# Точка в имени -- допустимо, но здесь её не будет.
					if not (лит in "~`!@$%^&*()-_=+{}[]|\\<,>?/\"№;:/"):
						бВыход = True
						break
		return бВыход

	def __str__(сам):
		стрСлово = сам.__стрСтрока
		while len(стрСлово) < 7:
			стрСлово = " " + стрСлово
		return str(сам.__номер)+"\tслово="+ стрСлово + "\t" + str(сам.коорд)
