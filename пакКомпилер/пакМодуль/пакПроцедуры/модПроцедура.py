# coding:utf8
"""
Модуль описывает тип процедуры. По сути, микромодуль.
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	from . модПроцПараметр import тПроцПараметр
	from пакКомпилер.пакМодуль.пакКонст import тКонст
	from пакКомпилер.пакМодуль.пакТипы  import тТипы
	from пакКомпилер.пакМодуль.пакПерем import тПеременные

class тПроцедура:
	def __init__(сам, пБаза, пСловаСекции):
		сам.база = пБаза
		сам.__корень = пБаза.корень
		сам.слова_секции = пСловаСекции
		сам.__имя = "" # Имя процедуры
		сам.__бЭкспорт = False
		сам.__бВозврат = False # признак возврата значения
		сам.__тВозврат = "" # Тип возвращаемого значения
		сам.__конст = {} # Возможные константы в процедуре
		сам.__типы = {}  # Возможные типы в процедуре
		сам.__перем = {} # Возможные переменные в процедуре
		сам.__проц = {} # Возможные процедуры в процедуре
		сам.слова_проц = {} # Слова в своей процедуре
		сам.__проц_конец = None # указатель на окончаниесвоей процедуры
		сам.параметры = {} # словарь параметров передаваемых в процедуру
		сам.__Процедура_Проверить()
		сам.__Имя_Проверить()
		сам.__КонецСвой_Найти()
		сам.__СловаПроц_Получить()
		сам.__Экспорт_Проверить()
		if сам.__СкобкаЛев_Открыть():
			сам.__Параметры_Проверить()
			сам.__СкобкаПрав_Закрыть()
			if сам.__Двоеточие_Обрезать():
				сам.__Возврат_Проверить()
		сам.__Разделитель_Обрезать()
		сам.__Константы_Проверить()
		сам.__Типы_Проверить()
		сам.__Переменные_Проверить()
		сам.__ПроцедурыВнутр_Проверить()

	def __СловаПроц_Получить(сам):
		"""
		Выбирает слова по своей процедуре.
		Дальше работает только с ними.
		"""
		слова_проц = {}  # будущий словарь слов секции процедур
		for цСчётПроц in range(0, сам.__проц_конец.номер - 1):
			слово = сам.слова_секции[цСчётПроц]
			слово._Номер_Уст(цСчётПроц)
			#print("пр+", слово)
			слова_проц[цСчётПроц] = слово
		сам.слова_проц = слова_проц

		слова_секции = {}  # будущий словарь слов секции
		цСчётМодуль = 0
		for цСчёт in range(сам.__проц_конец.номер+1, len(сам.слова_секции)):
			слово = сам.слова_секции[цСчёт]
			слово._Номер_Уст(цСчётМодуль)
			#print("т-", цСчёт, слово.номер, слово.слово)
			слова_секции[цСчётМодуль] = слово
			цСчётМодуль += 1
		сам.слова_секции = {}
		сам.слова_секции = слова_секции

	def __КонецСвой_Найти(сам):
		"""
		Разбор тела процедуры будет неправильным, если нет своего конца.
		Свой конец надо искать после нахождения своего имени.
		"""
		цКонец =  0
		слово0 = None
		слово1 = None
		слово2 = None
		print("%Имя своей процедуры:", сам.__имя)
		while цКонец < len(сам.слова_секции):
			слово0 = сам.слова_секции[цКонец]
			if слово0.строка =="END":
				слово1 = сам.слова_секции[цКонец+1]
				if слово1.строка == сам.__имя:
					слово2 = сам.слова_секции[цКонец+2]
					if слово2.строка == ";": # это точно конец процедуры
						print("%Есть конец этой процедуры!")
						break
			цКонец += 1
		сам.__проц_конец = сам.слова_секции[цКонец + 2]
		print("%Окончание процедуры:", сам.слова_секции[цКонец + 1])

	def __ПроцедурыВнутр_Проверить(сам):
		"""
		Процедура, по сути -- микромодуль, может содержать процедуры.
		Надо проверить.
		"""
		#TODO: процедур может быть несколько
		сам.__проц[len(сам.__проц)] = тПроцедура(сам, сам.слова_проц)
		сам.__проц.Обработать()
		сам.слова_секции = {}
		сам.слова_секции = сам.__проц.слова

	def __Переменные_Проверить(сам):
		"""
		Процедура, по сути -- микромодуль, может содержать переменные.
		Надо проверить.
		"""
		сам.__перем = тПеременные(сам.__корень, сам.слова_проц)
		сам.__перем.Обработать()
		сам.слова_секции = {}
		сам.слова_секции = сам.__перем.слова

	def __Типы_Проверить(сам):
		"""
		Процедура, по сути -- микромодуль, может содержать типы.
		Надо проверить.
		"""
		сам.__типы = тТипы(сам.__корень, сам.слова_проц)
		сам.__типы.Обработать()
		сам.слова_секции = {}
		сам.слова_секции = сам.__типы.слова

	def __Константы_Проверить(сам):
		"""
		Процедура, по сути -- микромодуль, может содержать констаты.
		Надо проверить.
		"""
		сам.__конст = тКонст(сам.__корень, сам.слова_проц)
		сам.__конст.Обработать()
		сам.слова_секции = {}
		сам.слова_секции = сам.__конст.слова

	def __Разделитель_Обрезать(сам):
		"""
		В простых типах последнее слово ";"
		Поэтому его необходимо обрезать
		"""
		строка_раздел = сам.Слово_Проверить()
		if строка_раздел == ";":
			сам.СловаСекции_Обрезать()
		else:
			assert False, "тПроцедура: неправильный разделитель, строка=" + строка_раздел

	def __Двоеточие_Обрезать(сам):
		"""
		Здесь может быть, а может и не быть ":"
		"""
		бДвоеточие = False
		строка_двоеточ = сам.Слово_Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()
			бДвоеточие = True
			print("Двоеточие обрезано")
		return бДвоеточие

	def __Возврат_Проверить(сам):
		"""
		Проверяет тип возврата процедуры. Должно быть разрешённой строкой.
		Кроме того, имя может быть составным
		"""
		стрОш = "тПроцедура: тип возврата должен быть допустимым именем, имя="
		строка_возврат = сам.Слово_Проверить()
		слово_возврат = сам.слова_секции[0]
		assert слово_возврат.ЕслиСтр_Допустимо(), стрОш + строка_возврат
		while not ((строка_возврат == ";") or (строка_возврат == ")")):
			сам.СловаСекции_Обрезать()
			сам.__тВозврат += строка_возврат
			строка_возврат = сам.Слово_Проверить()
			слово_возврат = сам.слова_секции[0]
			бРезульт = True
		assert сам.__тВозврат != "", "тПроцедура: тип возврата не может быть пустой строкой"
		print("Тип возврата:", сам.__тВозврат)
		return бРезульт

	def __Процедура_Проверить(сам):
		"""
		Проверяет наличие слова PROCEDURE среди слов секции
		"""
		строка_проц = сам.Слово_Проверить()
		бУсл = строка_проц == "PROCEDURE"
		стрОш = "тПроцедура: процедура должна начинаться PROCEDURE, строка=" + строка_проц
		assert бУсл, стрОш
		сам.СловаСекции_Обрезать()
		print("Процедура ========")

	def __Имя_Проверить(сам):
		"""
		Проверяет имя процедуры.
		Имя НЕ МОЖЕТ быть составным
		"""
		имя = сам.Слово_Проверить()
		слово_имя = сам.слова_секции[0]
		if слово_имя.ЕслиИмя_Строго():
			сам.СловаСекции_Обрезать()
			сам.__имя = имя
		else:
			assert False, "тПроцедура: имя должно быть допустимым именем, имя=" + имя
		print("    Имя:", имя)

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является ли процедура экспортируемой.
		"""
		строка_экспорт = сам.Слово_Проверить()
		if строка_экспорт == "*": # есть экспорт
			сам.СловаСекции_Обрезать()
			сам.__бЭкспорт = True
		elif строка_экспорт == "(":
			pass # это начало входных условий
		else:
			слово = сам.слова_секции[0]
			assert False, "тПроцедура: литера экспорта допустима '*' или '(',    строка=" + строка_экспорт + "  " + слово.стрИсх
		print("    бЭкспорт:", сам.__бЭкспорт)

	def __СкобкаЛев_Открыть(сам):
		"""
		Проверяет на открытие левой скобки (значит есть входные параметры)
		В этой позиции может быть скобка, а может и нет. Надо проверять.
		"""
		бРезультат = False
		строка_скобка = сам.Слово_Проверить()
		if строка_скобка == "(":
			бРезультат = True
			сам.СловаСекции_Обрезать()
		print("Есть параметры процедуры:")
		return бРезультат

	def __СкобкаПрав_Закрыть(сам):
		"""
		Проверяет на закрытие правой скобки
		В этой позиции должна быть скобка.
		"""
		строка_скобка = сам.Слово_Проверить()
		if строка_скобка == ")":
			сам.СловаСекции_Обрезать()
		else:
			assert False, "тПроцедура: Параметры должны заканчиваться ')', слово=" +строка_скобка
		print("Конец параметров процедуры")

	def __Параметры_Проверить(сам):
		"""
		Получает параметры процедуры.
		Крутит до тех пор, пока слово не станет ")"
		"""
		строка = сам.Слово_Проверить()
		while строка != ")": # есть зарытие параметров
			параметр = None
			параметр = тПроцПараметр(сам)
			сам.параметры[len(сам.параметры)] = параметр
			строка = сам.Слово_Проверить()

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	def Слово_Проверить(сам):
		"""
		Проверяет первое слово в словаре слов секции на допустимость.
		"""
		слово = сам.слова_секции[0]
		assert type(слово) == тСлово, "тТипБазовый: слово должно быть тСлово, тип="+str(type(слово))
		строка = слово.строка
		assert type(строка) == str, "тТипБазовый: строка должна быть 'str', type=" + str(type(строка))
		assert строка != "", "тТипБазовый: строка не может быть пустой"
		return строка

	def Паспорт_Печать(сам):
		print("тПроцедура: надо доделать Паспорт_Печать()")

	@property
	def корень(сам):
		return сам.__корень
