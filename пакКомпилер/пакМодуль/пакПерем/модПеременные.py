# coding: utf8
"""
Модуль "модПеременные".
Пакет содержит в себе определение секции переменных.
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакПоле.модПоле import тПоле
	from пакКомпилер.пакМодуль.пакТипы.модРод import тРод

class тПеременные:
	def __init__(сам, пКорень, пСловаМодуля):
		def Слова_Проверить():
			бУсл = type(пСловаМодуля) == dict
			стрОш = "В секцию переменных должен передаваться словарь слов, type=" + str(type(пСловаМодуля))
			пКорень.конс.Проверить(бУсл, стрОш)
		сам.__корень = пКорень
		Слова_Проверить()
		сам.__слова_модуль = пСловаМодуля
		сам.слова_секции = {} #  Все пСлова секции VAR
		сам.__перем = {} # словарь по словам каждой глобальной переменной в модуле
		сам.__бПеремЕсть = False # По умлочанию секции VAR нет
		сам.ошибка = пКорень.ошибка

	def __Слово_VAR_Обрезать(сам):
		"""
		Первое слово в списке слов должно быть VAR.
		Если нет -- значит в исходнике нет описания типов.
		Возвращает результат встречи с VAR
		"""
		слово = сам.__слова_модуль[0]
		if слово.строка =='VAR':
			# укоротить типы
			слова = {}
			for счёт in range(1, len(сам.__слова_модуль)):
				слово = сам.__слова_модуль[счёт]
				слово._Номер_Уст(счёт-1)
				слова[счёт-1] = слово
			сам.__слова_модуль = {}
			сам.__слова_модуль = слова
			сам.__бПеремЕсть = True
		return сам.__бПеремЕсть

	def __ЕслиПеремНеПустые(сам):
		"""
		Может быть следующее слово после окончания секции:   PROCEDURE BEGIN (* END модуля уже отброшено *)
		Секция VAR не может быть пустой, но если есть типы, они должны заканчиваться на ;
		"""
		def Слово_Проверить():
			бУсл = (type(слово) == тСлово)
			стрОш = "Слово должно быть тСлово, type=" + str(type(слово))
			корень.конс.Проверить(бУсл, стрОш)
		корень = сам.__корень

		слово = сам.__слова_модуль[0] # первое слово после VAR, а сам VAR уже распознан и отброшен
		Слово_Проверить()

		# проверим на внезапный конец секции
		бМаркер = (слово.строка in ["PROCEDURE", "BEGIN"])
		if not бМаркер: # секция переменных не пустая
			сам.__бПеремНеПустые = True
		return сам.__бПеремНеПустые

	def __ЕслиПеремОграничены(сам):
		"""
		Ищет разделитель окончания переменных.
		Сканируем слова все подряд.
		Может быть следующее слово-маркер окончания секции типов: PROCEDURE BEGIN,
		Первое слово всегда должен быть именем переменной и не может быть маркером
		Произвольное слово может быть ";" и не может быть маркером
		"""
		def Слово_Проверить():
			бУсл = type(слово) == тСлово
			стрОш = "тПеременные: Слово должно быть тСлово, type=" + str(type(слово))
			корень.конс.Проверить(бУсл, стрОш)
		def Маркер():
			сам.__бМаркер = (слово.строка in ["PROCEDURE", "BEGIN"])
		корень = сам.__корень
		цСловМодульВсего = len(сам.__слова_модуль) - 1 # отсчёт начинается с нуля
		цСловоСчёт = 0 # первый слово после VAR, а сам VAR уже распознали и отбросили
		слово = сам.__слова_модуль[цСловоСчёт]
		Слово_Проверить()
		Маркер()
		while (not сам.__бМаркер) and (цСловоСчёт < цСловМодульВсего ):
			цСловоСчёт += 1
			слово = сам.__слова_модуль[цСловоСчёт]

			Слово_Проверить()
			Маркер()
		цСловоСчёт -= 1
		слово = сам.__слова_модуль[цСловоСчёт]
		сам.__слово_конец = слово
		# Проверка на окончание секции типов
		if слово.строка != ";":
			сам.ошибка.Печать("тПеременные: слово ограничение секции типов должно быть ';', слово= " + слово.строка)

	def __СловаСекции_Получить(сам):
		"""
		Выбирает слова по секции переменных.
		Дальше работает только с ними.
		"""
		слова_секции = {}  # будущий словарь слов секции типов
		for цСчётПерем in range(0, сам.__слово_конец.номер+1): # VAR уже отброшено
			слово = сам.__слова_модуль[цСчётПерем]
			слово._Номер_Уст(цСчётПерем)
			#print("п+", цСчётПерем, "num",слово.номер, слово.слово)
			слова_секции[цСчётПерем] = слово
		сам.слова_секции = слова_секции

		слова_модуля = {}  # будущий словарь слов модуля
		цСчётМодуль = 0
		for цСчёт in range(сам.__слово_конец.номер+1, len(сам.__слова_модуль)):
			слово = сам.__слова_модуль[цСчёт]
			слово._Номер_Уст(цСчётМодуль)
			#print("т-", цСчёт, слово.номер, слово.слово)
			слова_модуля[цСчётМодуль] = слово
			цСчётМодуль += 1
		сам.__слова_модуль = {}
		сам.__слова_модуль = слова_модуля

	def __Перем_Разделить(сам):
		"""
		Пока не исчерпаны слова секции -- последовательно вызываем новый тип.
		"""
		while len(сам.слова_секции) > 0:
			print("Слов перем=", len(сам.слова_секции))
			перем = None
			перем = тПоле(сам, None)
			перем.Паспорт_Печать()
			сам.__перем[len(сам.__перем)] = перем

	def СловаМодуля_Печать(сам):
		сам.__корень.конс.Печать("\nтТипы.СловаМодуля_Печать()")
		for ключ in сам.__слова_модуль:
			слово = сам.__слова_модуль[ключ]
			сам.__корень.конс.Печать(слово)

	def СловаСекции_Печать(сам):
		print("Слова секции VAR =======================================")
		сам.__корень.конс.Печать("\nпПеременные.СловаСекции_Печать()")
		for ключ in сам.слова_секции:
			слово = сам.слова_секции[ключ]
			сам.__корень.конс.Печать(слово.строка)

	def Обработать(сам):
		"""
		Проводит разбор секции VAR.
		"""
		if сам.__Слово_VAR_Обрезать():
			сам.__корень.конс.Печать("Есть переменные!")
		if сам.__ЕслиПеремНеПустые():
			сам.__корень.конс.Печать("Переменные не пустые!")
			#сам.__Перем_Печать()
			сам.__ЕслиПеремОграничены()
			#сам.Перем_Печать()
			сам.__СловаСекции_Получить()
			#сам.Перем_Печать()
			сам.__Перем_Разделить()
			сам.СловаСекции_Печать()
		else:
			print("Нет переменных!")

	def Слово_Проверить(сам):
		"""
		Проверяет первое слово в словаре слов секции на допустимость.
		"""
		слово = сам.слова_секции[0]
		assert type(слово) == тСлово, "тТипБазовый: слово должно быть тСлово, тип="+str(type(слово))
		строка = слово.строка
		assert type(строка) == str, "тТипБазовый: строка должна быть 'str', type=" + str(type(строка))
		assert строка != "", "тТипБазовый: строка не может быть пустой"
		return строка

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	def Элемент_Проверить(сам, пПоле):
		"""
		Проверяет предка записи. Должно быть разрешённой строкой и
		не должно быть END.
		Кроме того, имя может быть составным
		"""
		стрОш = "тПеременные: тип элемента переменной должен быть допустимым именем, имя="
		имя = сам.Слово_Проверить()
		слово_имя = сам.слова_секции[0]
		assert слово_имя.ЕслиСтр_Допустимо(), стрОш + имя
		assert пПоле.поле.массив_тип == тРод.сБезТипа, "тПоле: элемент массива уже назначен, элемент=" + сам.массив_тип
		элемент = ""
		while (имя == ".") or (слово_имя.ЕслиСтр_Допустимо()):
			сам.СловаСекции_Обрезать()
			элемент += имя
			имя = сам.Слово_Проверить()
			слово_имя = сам.слова_секции[0]
		return элемент

	@property
	def слова(сам):
		return сам.__слова_модуль
