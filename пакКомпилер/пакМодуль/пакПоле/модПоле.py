# coding:utf8
"""
Модуль описывает поле ранее описанного типа в составе записи.
"""
if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакТипы.модРод import тРод
	from . модПолеВстроен import тПолеВстроен
	from . модПолеМассив import тПолеМассив

class тПоле:
	def __init__(сам, пТип):
		сам.база = пТип  # ссылка на тТип
		сам.__имя = ""
		сам.__тип = ""
		сам.__поле_словарь =  {} # если вдруг поле окажется составным
		сам.__бЭкспорт = False
		сам.__бУказатель = False
		сам.массив_размерность = {} # размерность массива поля (если поле массив)
		if сам.__Имя_Проверить():
			сам.__Экспорт_Проверить()
			сам.__Двоеточие_Обрезать()
			сам.__Род_Проверить() # основная работа по родам полей
			сам.__Разделитель_Обрезать()

	def __Разделитель_Обрезать(сам):
		"""
		В полях может и не встречаться как разделитель ";", так и
		окончание описания типа "END"+";".
		Обработку "END" оставляем на совести типа.
		"""
		строка_раздел = сам.база.Слово_Проверить()
		if строка_раздел == ";": # закрытие имени предка
			сам.база.СловаСекции_Обрезать()
		print("Поле разд:", строка_раздел)

	def __Двоеточие_Обрезать(сам):
		"""
		Здесь может быть только ":"
		Даже для описания встроенных в типы записей
		"""
		строка_двоеточ = сам.база.Слово_Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.база.СловаСекции_Обрезать()
		else: # а это уже непонятно что
			assert False, "тПоле: разделитель должна быть ':',    строка=" + строка_двоеточ

	def __Имя_Проверить(сам):
		"""
		Получает имя поля.
		"""
		бРезульт = False
		имя = сам.база.Слово_Проверить()
		слово_имя = сам.база.слова_секции[0]
		assert слово_имя.ЕслиИмя(), "тПоле: имя поля должно быть допустимым именем, имя=" + имя
		if имя != "END":
			сам.__имя = имя
			сам.база.СловаСекции_Обрезать()
			бРезульт = True
			print("Поле имя:", слово_имя)
		return бРезульт

	def __Тип_Проверить(сам):
		"""
		Получает тип поля.
		Тип поля в данном случае определяется пользователем в коде
		"""
		строка_тип = сам.база.Слово_Проверить()
		слово_тип = сам.база.слова_секции[0]
		assert слово_тип.ЕслиИмя(), "тПоле: тип поля должен быть допустимым именем, тип=" + строка_тип
		assert строка_тип != "END", "тПоле: тип не может быть 'END'"
		сам.__тип = строка_тип
		сам.база.СловаСекции_Обрезать()
		print("Поле тип:", строка_тип)

	def __Род_Проверить(сам):
			"""
			Пытается вычислить поле в простой записи.
			слово тип может быть как встроенным, так и определяемое пользователем.
			"""
			строка_тип = сам.база.Слово_Проверить()
			слово_тип = сам.база.слова_секции[0]
			if строка_тип in тРод.тип_встроен:
				поле = тПолеВстроен(сам)
			elif строка_тип == "ARRAY":
				поле = тПолеМассив(сам)
			elif слово_тип.ЕслиИмя() and (строка_тип != "END"):
				# если пользовательский тип
				сам.__Тип_Проверить()

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является ли поле экспортируемым.
		Эта процедура продублирована из тТипБазовый, так как
		у поля свой признак экспорта, а типа свой.
		"""
		строка_экспорт = сам.база.Слово_Проверить()
		if строка_экспорт == "*": # есть экспорт
			сам.__бЭкспорт = True
			сам.база.СловаСекции_Обрезать()
		elif строка_экспорт == ":":
			# это определение внутреннего поля, экспорт уже установлен как надо
			pass
		else:
			assert False, "тПоле: Символ экспорта допустим '*' или ':',    строка=" + строка_экспорт

	def Тип_Уст(сам, пТип):
		"""
		Тип поля должен быть типом в тРод.
		"""
		assert type(пТип) == str, "Тип поля должен быть типом str, тип=" + str(type(пТип))
		сам.__тип = пТип

	@property
	def тип(сам):
		return сам.__тип

	def Паспорт_Печать(сам):
		print("       Поле: ", сам.__имя)
		print("         экспорт= ", сам.__бЭкспорт)
		print("      указатель =", сам.__бУказатель)
		print("           тип  =", сам.__тип)
		if сам.__тип == тРод.сМассив:
			for ключ in range(len(сам.массив_размерность)):
				print("          ключ ", ключ, ":",сам.массив_размерность[ключ])
			print("          элем    =", сам.массив_тип)
		if сам.__тип == тРод.сЗапись:
			for ключ in range(len(сам.запись_поля)):
				сам.запись_поля[ключ].Паспорт_Печать
		print()
