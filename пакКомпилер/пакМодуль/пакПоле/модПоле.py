# coding:utf8
"""
Модуль описывает поле ранее описанного типа в составе записи.
"""
if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакТипы.модРод import тРод
	from . модПолеВстроен import тПолеВстроен
	from . модПолеМассив import тПолеМассив
	from . модПолеЗапись import тПолеЗапись

class тПоле:
	def __init__(сам, пТип, пЗапись):
		сам.база = пТип  # ссылка на тТип
		сам.поле = пЗапись
		сам.__имя = ""
		сам.__тип = ""
		сам.__бЭкспорт = False
		сам.__бУказатель = False
		сам.поля ={} # если вдруг поле окажется составным
		сам.массив_размерность = {} # размерность массива поля (если поле массив)
		сам.массив_тип = тРод.сБезТипа # Тип элемента массива
		сам.__Имя_Проверить()
		сам.__Экспорт_Проверить()
		сам.__Двоеточие_Обрезать()
		сам.__Род_Проверить() # основная работа по родам полей
		сам.__Разделитель_Обрезать()

	def __Разделитель_Обрезать(сам):
		"""
		В полях может и не встречаться как разделитель ";", так и
		окончание описания типа "END"+";".
		Обработку "END" оставляем на совести типа.
		"""
		строка_раздел = сам.база.Слово_Проверить()
		if строка_раздел == ";": # закрытие имени предка
			сам.база.СловаСекции_Обрезать()

	def __Двоеточие_Обрезать(сам):
		"""
		Здесь может быть только ":"
		Даже для описания встроенных в типы записей
		"""
		строка_двоеточ = сам.база.Слово_Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.база.СловаСекции_Обрезать()
		else: # а это уже непонятно что
			assert False, "тПоле: разделитель должна быть ':',    строка=" + строка_двоеточ

	def __Имя_Проверить(сам):
		"""
		Получает имя поля.
		"""
		имя = сам.база.Слово_Проверить()
		слово_имя = сам.база.слова_секции[0]
		if слово_имя.ЕслиИмя():
			сам.__имя = имя
			сам.база.СловаСекции_Обрезать()
		else:
			assert слово_имя.ЕслиИмя(), "тПоле: имя поля должно быть допустимым именем, имя=" + имя

	def __Тип_Проверить(сам):
		"""
		Получает тип поля.
		Тип поля в данном случае определяется пользователем в коде
		"""
		строка_тип = ""
		while True:
			сам.__тип += строка_тип
			строка_тип = сам.база.Слово_Проверить()
			#слово_тип = сам.база.слова_секции[0]
			if (строка_тип != "END") and (строка_тип != ";"):
				сам.база.СловаСекции_Обрезать()
			else:
				break



	def __Род_Проверить(сам):
			"""
			Пытается вычислить поле в простой записи.
			слово тип может быть как встроенным, так и определяемое пользователем.
			"""
			строка_тип = сам.база.Слово_Проверить()
			слово_тип = сам.база.слова_секции[0]
			if строка_тип in тРод.тип_встроен:
				поле = тПолеВстроен(сам)
			elif строка_тип == "ARRAY":
				поле = тПолеМассив(сам)
			elif строка_тип == "RECORD":
				поле = тПолеЗапись(сам)
			elif слово_тип.ЕслиИмя() and (строка_тип != "END"):
				# если пользовательский тип
				сам.__Тип_Проверить()

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является ли поле экспортируемым.
		Эта процедура продублирована из тТипБазовый, так как
		у поля свой признак экспорта, а типа свой.
		"""
		строка_экспорт = сам.база.Слово_Проверить()
		if строка_экспорт == "*": # есть экспорт
			сам.__бЭкспорт = True
			сам.база.СловаСекции_Обрезать()
		elif строка_экспорт == ":":
			# это определение внутреннего поля, экспорт уже установлен как надо
			pass
		else:
			assert False, "тПоле: Символ экспорта допустим '*' или ':',    строка=" + строка_экспорт

	def Тип_Уст(сам, пТип):
		"""
		Тип поля должен быть типом в тРод.
		"""
		assert type(пТип) == str, "Тип поля должен быть типом str, тип=" + str(type(пТип))
		сам.__тип = пТип

	def Поля_Проверить(сам, пПолеЗапись):
		"""
		В записях ВСЕГДА встречается окончание "END" даже без
		вложенных полей.
		Поэтому здесь проверяем в цикле все поля, пока не закончатся
		Здесь подполям передаётся ссылка НА ЭТО поле
		Процедура помещена сюда, так как по другому получается
		циклический импорт.
		"""
		строка_конец = сам.база.Слово_Проверить()
		# если типы не встроенные (у встроенных типов нет полей)
		while строка_конец != "END": # нет окончания описания типа
			поле = тПоле(сам.база, сам)
			сам.поля[len(сам.поля)] = поле
			строка_конец = сам.база.Слово_Проверить()

	@property
	def имя(сам):
		return сам.__имя

	@property
	def тип(сам):
		return сам.__тип

	@property
	def слова_секции(сам):
		return сам.база.слова_секции

	def Паспорт_Печать(сам):
		print("       Поле: ", сам.__имя)
		print("         экспорт= ", сам.__бЭкспорт)
		print("      указатель =", сам.__бУказатель)
		print("           тип  =", сам.__тип)
		if сам.__тип == тРод.сМассив:
			for ключ in range(0, len(сам.массив_размерность)):
				print("          ключ ", ключ, ":",сам.массив_размерность[ключ])
			print("          элем    =", сам.массив_тип)
		if сам.__тип == тРод.сЗапись:
			print("Поля:")
			for ключ in сам.поля:
				сам.поля[ключ].Паспорт_Печать()
		print()
