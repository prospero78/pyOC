# coding: utf8
"""
Модуль "Импорт" содержит процедуры анализа возможного импорта модулей.
"""
if True:
	from пакКомпилер.пакСлово import тСлово
	from .модАлиас import тАлиас

class тИмпорт:
	def __init__(сам, корень, пСлова):
		def СловаСловарь_Проверить():
			бУсл = type(пСлова) == dict
			стрСообщ = "В секцию импорта должен передаваться словарь слов, type="+       str(type(пСлова))
			корень.конс.Проверить(бУсл, стрСообщ)
			assert type(пСлова) == dict, "В секцию импорта должен передаваться словарь слов, type="+type(пСлова)
		сам.__корень = корень
		сам.ошибка = корень.ошибка
		
		СловаСловарь_Проверить()
		сам.__слова = пСлова
		
		сам.__имптеги = {}
		сам.__бИмпорт = False # Признак наличия импорта
		сам.__бИмпортОдин = False # Признак того, что импорт одиночный
		
		сам.__тег_конец = None
		сам.__импорт = {} # Содержит словарь импорта
		сам.__цМодули = 0

	def ЕслиИмпорт(сам):
		"""
		Первый тег в списке тегов должен быть IMPORT.
		Если нет -- значит в исходнике нет импорта.
		IMPORT не может быть пустым.
		"""
		тег = сам.__слова[0]
		if тег.слово =='IMPORT':
			бВыход = True
		else:
			бВыход = False
		сам.__бИмпорт = бВыход
		return бВыход

	@property
	def бИмпорт(сам):
		return сам.__бИмопрт

	@property
	def импорт(сам):
		return сам.__импорт

	@property
	def слова(сам):
		return сам.__слова

	def ЕслиИмпортОдин(сам):
		счёт_импорт = 0
		тег_счёт = 0
		всего = len(сам.__слова)
		while тег_счёт < всего:
			тег = сам.__слова[тег_счёт]
			if тег.слово == 'IMPORT':
				счёт_импорт += 1
				if счёт_импорт > 1:
					сам.ошибка.Коорд("IMPORT два раза в одном модуле запрещён", тег.коорд, тег.стр)
			тег_счёт += 1
		сам.__бИмпортОдин = True
		return счёт_импорт

	def ЕслиИмпортОграничен(сам):
		"""
		Ищет разделитель окончания импорта.
		Должны быть ключевые слова CONST, TYPE, VAR, PROCEDURE, BEGIN
		"""
		тег_всего = len(сам.__слова)-1
		тег_счёт = 1 # первый тег после ИМПОРТ, а сам ИМПОРТ уже распознан
		тег = сам.__слова[тег_счёт]
		assert type(тег) == тСлово, "тИмпорт: Слово должно быть тСлово, type="+type(тег)
		маркер = (тег.слово == "CONST") or \
					(тег.слово == "TYPE") or \
					(тег.слово == "VAR") or \
					(тег.слово == "PROCEDURE") or \
					(тег.слово == "BEGIN")
		while not маркер and тег_счёт < тег_всего:
			тег_счёт += 1
			тег = сам.__слова[тег_счёт]
			assert type(тег) == тСлово, "тИмпорт: Слово должно быть тСлово, type="+type(тег)
			маркер = (тег.слово == "CONST") or \
						(тег.слово == "TYPE") or \
						(тег.слово == "VAR") or \
						(тег.слово == "PROCEDURE") or \
						(тег.слово == "BEGIN")
		if тег_счёт == тег_всего:
			сам.ошибка.Печать( "Секция IMPORT нигде не заканчивается ")
		тег_счёт -= 1
		тег = сам.__слова[тег_счёт]
		сам.__тег_конец = тег

	def Теги_Получить(сам):
		"""
		Выбирает теги по секции импорта.
		Дальше работает только с ними.
		"""
		теги = {}  # будущий словарь тегов
		# Пропускаем IMPORT
		for счёт_импорт in range(1, сам.__тег_конец.номер+1):
			тег = сам.__слова[счёт_импорт]
			тег._Номер_Уст(счёт_импорт-1)
			#print("и+", счёт_импорт, тег.номер, тег.имя)
			теги[счёт_импорт-1] = тег
		сам.__имптеги = теги

		теги = {}  # будущий словарь тегов
		счёт = 0
		# Пропускаем финальный ";" в импорте
		for счёт_импорт in range(сам.__тег_конец.номер+2, len(сам.__слова)):
			тег = сам.__слова[счёт_импорт]
			тег._Номер_Уст(счёт)
			#print("и-",счёт_импорт, тег.номер, тег.имя)
			теги[счёт] = тег
			счёт += 1
		сам.__слова = {}
		сам.__слова = теги

	def Импорт_Разобрать(сам):
		"""
		Делает разбор импорта, вычисляет алиасы.
		"""
		def Модуль_Доб(тег):
			assert type(тег) == тСлово, "тИмпорт: Добавлемое слово должен быть тСлово, type="+type(тег)
			assert тег != None, "Тег не может быть None"
			assert тег.слово != None or тег.слово != "", "Имя модуля не может быть None или пустым"

			имп = тАлиас("", тег.слово, сам.__цМодули)

			сам.__импорт[сам.__цМодули] = имп
			сам.__цМодули += 1

		def Алиас_Добавить(алиас, имя):
			assert type(алиас) == тСлово, "тИмпорт: Алиас должен быть тСлово, type="+type(алиас)
			assert алиас != None, "тИмпорт: Алиас не может быть None"
			assert алиас.слово != None, "тИмпорт: Имя алиаса не может быть None"

			assert type(имя) == тСлово, "тИмпорт: Имя модуля должно быть тСлово, type="+type(имя)
			assert имя != None, "тИмпорт: имя не может быть None"
			assert имя.слово != None or имя.слово != "", "тИмпорт: Имя модуля не может быть None или пустым"
			имп = тАлиас(алиас.слово, имя.слово, сам.__цМодули)

			сам.__импорт[сам.__цМодули] = имп
			сам.__цМодули += 1

		#print("тИмпорт.Импорт_Разобрать()")
		# второй тег должен быть один из трёх вариантов
		тег_счёт = 1
		имп_теги = сам.__имптеги
		while тег_счёт < len(имп_теги):
			тег = имп_теги[тег_счёт]
			#print(тег_счёт, тег.слово)
			if тег.слово == "," or тег.слово == ";":
				Модуль_Доб(имп_теги[тег_счёт-1])
				тег_счёт += 2
			elif тег.слово == ":=":
				Алиас_Добавить(имп_теги[тег_счёт-1], имп_теги[тег_счёт+1])
				тег_счёт += 4
			else: # неправильный разделитель
				сам.ошибка.Коорд("Неверный разделитель в импорте, тег= '"+имп_теги[тег_счёт-1].слово+"'", \
							имп_теги[тег_счёт-1].коорд, имп_теги[тег_счёт-1].стр)

	def Теги_Печать(сам):
		print("\nтИмпорт.Теги_Печать()")
		for keys in сам.__слова:
			тег = сам.__слова[keys]
			print(тег)

	def Имп_Печать(сам):
		print("\nтИмпорт.Имп_Печать()")
		for keys in сам.__имптеги:
			тег = сам.__имптеги[keys]
			print(тег)

	def Алиасы_Печать(сам):
		print("\nтИмпорт.Алиасы_Печать()")

		for keys in сам.__импорт:
			имп = сам.__импорт[keys]

			print(имп.номер, ":")
			if имп.бАлиас:
				print("    алиас: "+имп.алиас+";  слово: "+имп.слово)
			else:
				print("    слово: "+имп.слово)
			print

	@property
	def бИмпортОдин(сам):
		return сам.__бИмпортОдин

	def Обработать(сам):
		"""
		Обеспечивает обработку импорта модуля.
		"""
		if сам.ЕслиИмпорт():
			print("Есть импорт!")
			сам.ЕслиИмпортОдин()
			сам.ЕслиИмпортОграничен()
			сам.Теги_Получить()
			сам.Импорт_Разобрать()
			#сам.Имп_Печать()
			#сам.Алиасы_Печать()
			#сам.Теги_Печать()
