"""
Модуль "Импорт" содержит процедуры анализа возможного импорта модулей.
"""
if True:
   from пакКомпилер.пакТег.модТег import тТег
   from .модАлиас import тАлиас

class тИмпорт:
   def __init__(self, root, теги):
      self.__root = root
      
      усл = type(теги) == dict
      _текст = "В секцию импорта должен передаваться словарь тегов, type="+       str(type(теги))
      root.конс.Проверить(усл, _текст)
      assert type(теги) == dict, "В секцию импорта должен передаваться словарь тегов, type="+type(теги)
      self.__теги = теги
      
      self.__имптеги = {}
      self.__бИмпорт = False # Признак наличия импорта
      self.__бИмпортОдин = False # Признак того, что импорт одиночный
      self.ошибка = root.ошибка
      self.__тег_конец = None
      self.__импорт = {} # Содержит словарь импорта
      self.__цМодули = 0

   def ЕслиИмпорт(self):
      """
      Первый тег в списке тегов должен быть IMPORT.
      Если нет -- значит в исходнике нет импорта.
      IMPORT не может быть пустым.
      """
      тег = self.__теги[0]
      if тег.имя =='IMPORT':
         бВыход = True
      else:
         бВыход = False
      self.__бИмпорт = бВыход
      return бВыход

   @property
   def бИмпорт(self):
      return self.__бИмопрт

   @property
   def импорт(self):
      return self.__импорт

   @property
   def теги(self):
      return self.__теги

   def ЕслиИмпортОдин(self):
      счёт_импорт = 0
      тег_счёт = 0
      всего = len(self.__теги)
      while тег_счёт < всего:
         тег = self.__теги[тег_счёт]
         if тег.имя == 'IMPORT':
            счёт_импорт += 1
            if счёт_импорт > 1:
               self.ошибка.Коорд("IMPORT два раза в одном модуле запрещён", тег.коорд, тег.стр)
         тег_счёт += 1
      self.__бИмпортОдин = True
      return счёт_импорт

   def ЕслиИмпортОграничен(self):
      """
      Ищет разделитель окончания импорта.
      Должны быть ключевые слова CONST, TYPE, VAR, PROCEDURE, BEGIN
      """
      тег_всего = len(self.__теги)-1
      тег_счёт = 1 # первый тег после ИМПОРТ, а сам ИМПОРТ уже распознан
      тег = self.__теги[тег_счёт]
      assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
      маркер = (тег.имя == "CONST") or \
               (тег.имя == "TYPE") or \
               (тег.имя == "VAR") or \
               (тег.имя == "PROCEDURE") or \
               (тег.имя == "BEGIN")
      while not маркер and тег_счёт < тег_всего:
         тег_счёт += 1
         тег = self.__теги[тег_счёт]
         assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
         маркер = (тег.имя == "CONST") or \
                  (тег.имя == "TYPE") or \
                  (тег.имя == "VAR") or \
                  (тег.имя == "PROCEDURE") or \
                  (тег.имя == "BEGIN")
      if тег_счёт == тег_всего:
         self.ошибка.Печать( "Секция IMPORT нигде не заканчивается ")
      тег_счёт -= 1
      тег = self.__теги[тег_счёт]
      self.__тег_конец = тег

   def Теги_Получить(self):
      """
      Выбирает теги по секции импорта.
      Дальше работает только с ними.
      """
      теги = {}  # будущий словарь тегов
      # Пропускаем IMPORT
      for счёт_импорт in range(1, self.__тег_конец.номер+1):
         тег = self.__теги[счёт_импорт]
         тег._Номер_Уст(счёт_импорт-1)
         #print("и+", счёт_импорт, тег.номер, тег.имя)
         теги[счёт_импорт-1] = тег
      self.__имптеги = теги

      теги = {}  # будущий словарь тегов
      счёт = 0
      # Пропускаем финальный ";" в импорте
      for счёт_импорт in range(self.__тег_конец.номер+2, len(self.__теги)):
         тег = self.__теги[счёт_импорт]
         тег._Номер_Уст(счёт)
         #print("и-",счёт_импорт, тег.номер, тег.имя)
         теги[счёт] = тег
         счёт += 1
      self.__теги = {}
      self.__теги = теги

   def Импорт_Разобрать(self):
      """
      Делает разбор импорта, вычисляет алиасы.
      """
      def Модуль_Доб(тег):
         assert type(тег) == тТег, "Добавлемый тег должен быть тТег, type="+type(тег)
         assert тег != None, "Тег не может быть None"
         assert тег.имя != None or тег.имя != "", "Имя модуля не может быть None или пустым"

         имп = тАлиас("", тег.имя, self.__цМодули)

         self.__импорт[self.__цМодули] = имп
         self.__цМодули += 1

      def Алиас_Добавить(алиас, имя):
         assert type(алиас) == тТег, "Алиас должен быть тТег, type="+type(алиас)
         assert алиас != None, "Алиас не может быть None"
         assert алиас.имя != None, "Имя алиаса не может быть None"

         assert type(имя) == тТег, "Имя модуля должен быть тТег, type="+type(имя)
         assert имя != None, "имя не может быть None"
         assert имя.имя != None or имя.имя != "", "Имя модуля не может быть None или пустым"
         имп = тАлиас(алиас.имя, имя.имя, self.__цМодули)

         self.__импорт[self.__цМодули] = имп
         self.__цМодули += 1

      #print("тИмпорт.Импорт_Разобрать()")
      # второй тег должен быть один из трёх вариантов
      тег_счёт = 1
      имп_теги = self.__имптеги
      while тег_счёт < len(имп_теги):
         тег = имп_теги[тег_счёт]
         #print(тег_счёт, тег.имя)
         if тег.имя == "," or тег.имя == ";":
            Модуль_Доб(имп_теги[тег_счёт-1])
            тег_счёт += 2
         elif тег.имя == ":=":
            Алиас_Добавить(имп_теги[тег_счёт-1], имп_теги[тег_счёт+1])
            тег_счёт += 4
         else: # неправильный разделитель
            self.ошибка.Коорд("Неверный разделитель в импорте, тег= '"+имп_теги[тег_счёт-1].имя+"'", \
                     имп_теги[тег_счёт-1].коорд, имп_теги[тег_счёт-1].стр)

   def Теги_Печать(self):
      print("\nтИмпорт.Теги_Печать()")
      for keys in self.__теги:
         тег = self.__теги[keys]
         print(тег)

   def Имп_Печать(self):
      print("\nтИмпорт.Имп_Печать()")
      for keys in self.__имптеги:
         тег = self.__имптеги[keys]
         print(тег)

   def Алиасы_Печать(self):
      print("\nтИмпорт.Алиасы_Печать()")

      for keys in self.__импорт:
         имп = self.__импорт[keys]

         print(имп.номер, ":")
         if имп.бАлиас:
            print("    алиас: "+имп.алиас+";  имя: "+имп.имя)
         else:
            print("    имя: "+имп.имя)
         print

   @property
   def бИмпортОдин(self):
      return self.__бИмпортОдин

   def Обработать(self):
      """
      Обеспечивает обработку импорта модуля.
      """
      if self.ЕслиИмпорт():
         print("Есть импорт!")
         self.ЕслиИмпортОдин()
         self.ЕслиИмпортОграничен()
         self.Теги_Получить()
         self.Импорт_Разобрать()
         #self.Имп_Печать()
         #self.Алиасы_Печать()
         #self.Теги_Печать()
