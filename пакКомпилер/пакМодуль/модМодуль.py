"""
Модуль предоставляет тип тМодуль.
Содержит процедуры по разбору модуля.

Модуль -- это контейнер с жёсткоё структурой.
Обязательно содержит:
1. Заголовок модуля
2. Окончание модуля.

Возможно содержит:
1. Секция импорта
2. Секцию констант
3. Секцию типов
4. Секцию переменных
5. Секцию процедур
6. Секция инициализации модуля.
"""

if True:
   from пакКомпилер.пакТег import тТег

   from .пакИмпорт import тИмпорт
   from .пакКонст import тКонст
   from .пакТипы import тТипы

class тМодуль:
   """
      Тип представляет иерархию модуля с секциями.
   """
   def __init__(self, root, теги):
      self.__имя = ""

      self.__root = root
      assert type(теги) == dict, "тМодуль.__init__(): Тип тегов должен быть словарём, type(теги)="+str(type(теги))
      # содержимое словаря не контролируется
      self.__теги = теги
      self.__имя  = "" # имя модуля
      self.__конец = 0 # номер тега END <module_name>.
      self.__бМодульОдин = False # Признак, что MODULE встречается один раз
      self.ошибка = root.ошибка

      #self.импорт = тИмпорт(self.__теги)
      self.__импорт = None # объекты импорта
      self.__конст = None
      self.__типы = None
      self.перем = {}
      self.процедуры = {}
      self.начать = {}

   def Модуль_Первый(self):
      """
      Тег MODULE  в исходнике должен идти первым.
      """
      тег = self.__теги[0]
      # проверить, что тег является тТег
      assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
      if тег.имя != "MODULE":
         self.ошибка.Коорд("В файле отсутствует MODULE", тег.коорд, тег.стр + " имя="+тег.имя)

   def Имя_Второе(self):
      """
      Второй тег должно быть правильное имя модуля.
      """
      тег = self.__теги[1]
      assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
      if not тег.ЕслиИмя():
         self.ОшибкаКоорд("Нарушение имени модуля, имя="+тег.имя, тег.коорд)
      # запомним имя модуля
      self.__имя = self.__теги[1].имя

   def Заголовок_Конец(self):
      """
      Третьим тегом идёт окончание заголовка модуля.
      """
      тег = self.__теги[2]
      assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
      if тег.имя!=";":
         self.ошибка.Коорд("Нарушение окончания имени модуля, тег="+тег.имя, тег.коорд)
      # Обрезать заголовок модуля
      счёт_новый = 0
      теги = {}
      for счёт in self.__теги:
         if счёт > 2:
            тег = self.__теги[счёт]
            тег._Номер_Уст(счёт_новый)
            теги[счёт_новый] = тег
            счёт_новый += 1
      self.__теги = теги

   def Модуль_Конец(self):
      """
      Вычисляет окончание модуля.
      """
      тег_счёт = len(self.__теги)-1
      while тег_счёт > -1:
         тег = self.__теги[тег_счёт]
         assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
         if тег.имя == "." and self.__теги[тег_счёт-2].имя=="END": # Между ними -- возможно имя модуля
            if self.__теги[тег_счёт-1].имя == self.__имя:
               self.__конец = self.__теги[тег_счёт-2].номер
               break
            else: # имя модуля в начале и конце -- не совпало
               self.ошибка.Коорд("Имя модуля не совпадает, тег="+self.__теги[тег_счёт-1].имя, \
                        self.__теги[тег_счёт-1].коорд)
         тег_счёт -= 1
      if тег_счёт == -1:
         self.ошибка.Печать("Нет окончания модуля "+self.__имя)

      # теперь отбросим окончание модуля.
      счёт_новый = 0
      теги = {}
      for счёт in self.__теги:
         if счёт < self.__конец:
            тег = self.__теги[счёт]
            тег._Номер_Уст(счёт_новый)
            теги[счёт_новый] = тег
            счёт_новый += 1
      self.__теги = теги

   def Модуль_Один(self):
      # Слово MODULE должно быть одно.
      счётчик_модуль = 0
      for номер_тега in self.__теги:
         тег = self.__теги[номер_тега]
         assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
         if тег.имя == "MODULE":
            счётчик_модуль += 1
            if счётчик_модуль > 1:
               self.ошибка.Коорд("MODULE в файле должно быть только один раз!", тег.коорд, тег.стр)

   def Модуль_BEGIN(self):
      '''
      Контроль на наличие секции BEGIN в модуле.
      Просматриваем модуль снизу вверх до первого BEGIN
      '''
      счёт_тег = len(self.__тег)-1
      while счёт_тег >= 0:
         """
         #TODO: тут нужно доделать обработку.
         Да и с неё надо бы начать.
         """



   def Модуль_Контроль(self):  # Проверить правильность объявления модуля.
      '''
      Контроль на правильное открытие и закрытие модуля.
      '''
      self.Модуль_Первый()
      self.Имя_Второе()
      self.Заголовок_Конец()
      self.Модуль_Конец()
      self.Модуль_Один()

   def Теги_Печать(self):
      print("\nтМодуль.Теги_Печать() "+self.__имя)
      for keys in self.__теги:
         тег = self.__теги[keys]
         print(тег)

   def Секции_Разбить(self):
      '''
         Разбитие на глобальные секции:
         MODULE
            IMPORT
            CONST
            TYPE
            VAR
            PROCEDURE
         BEGIN [module]
         END [module]
      '''
      self.__импорт = тИмпорт(self.__root, self.__теги)
      self.__импорт.Обработать()
      self.__теги = {}
      self.__теги = self.__импорт.теги

      self.__конст = тКонст(self.__root, self.__теги)
      self.__конст.Обработать()
      self.__теги = {}
      self.__теги = self.__конст.теги

      self.__типы = тТипы(self.__root, self.__теги)
      self.__типы.Обработать()


   def Обработать(self):
      self.Модуль_Контроль()
      #self.Теги_Печать()
      self.Секции_Разбить()

   @property
   def имя(self):
      return self.__имя

   @property
   def теги(self):
      return self.__теги
