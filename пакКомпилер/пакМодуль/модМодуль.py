# coding: utf8
"""
Модуль предоставляет тип тМодуль.
Содержит процедуры по разбору модуля.

Модуль -- это контейнер с жёсткой структурой.
Обязательно содержит:
1. Заголовок модуля
2. Окончание модуля.

Возможно содержит:
1. Секция импорта
2. Секцию констант
3. Секцию типов
4. Секцию переменных
5. Секцию процедур
6. Секция инициализации модуля.
"""

if True:
	from пакКомпилер.пакСлово import тСлово

	from .пакИмпорт import тИмпорт
	from .пакКонст import тКонстанты
	from .пакТипы import тТипы
	from .пакПерем import тПеременные
	from .пакПроцедуры import тПроцедуры

class тМодуль:
	"""
		Тип представляет иерархию модуля с секциями.
	"""
	def __init__(сам, пКорень, слова):
		def СловаСловарь_Проверить():
			бУсл = type(слова) == dict
			стрСообщ = "тМодуль.__init__(): Тип слов должен быть словарём, type(слова)=" + \
						str(type(слова))
			assert бУсл, стрСообщ

		сам.__имя = ""
		сам.__корень = пКорень
		сам.__конс = пКорень.конс
		сам.__ошибка = пКорень.ошибка

		СловаСловарь_Проверить()
		# содержимое словаря не контролируется
		сам.__слова = слова
		сам.__имя  = "" # имя модуля
		сам.__конец = 0 # номер тега END <module_name>.
		сам.__бМодульОдин = False # Признак, что MODULE встречается один раз
		сам.__ошибка = пКорень.ошибка

		#сам.импорт = тИмпорт(сам.__слова)
		сам.__импорт = {} # объекты импорта
		сам.__конст = {}  # объекты констант
		сам.__типы = {}   # объекты типов
		сам.__перем = {}  # объекты переменных
		сам.__проц = {}# объекты процедур
		сам.начать = {}

	def Модуль_Первый(сам):
		"""
		слово MODULE  в исходнике должен идти первым.
		"""
		слово = сам.__слова[0]
		# проверить, что слово является тСлово
		assert type(слово) == тСлово, "Слово должно быть тСлово, type="+type(слово)
		if слово.строка != "MODULE":
			сам.ошибка.Коорд("В файле отсутствует MODULE", слово.коорд, слово.стр + " слово="+слово.слово)

	def Имя_Второе(сам):
		"""
		Второй слово должно быть правильное имя модуля.
		"""
		слово = сам.__слова[1]
		assert type(слово) == тСлово, "Слово должно быть тСлово, type="+type(слово)
		if not слово.ЕслиИмя_Строго():
			сам.ОшибкаКоорд("Нарушение имени модуля, имя="+слово.имя, слово.коорд)
		# запомним имя модуля
		сам.__имя = сам.__слова[1].строка
	def Заголовок_Конец(сам):
		"""
		Третьим тегом идёт окончание заголовка модуля.
		"""
		слово = сам.__слова[2]
		assert type(слово) == тСлово, "Слово должно быть тСлово, type="+type(слово)
		if слово.строка != ";":
			сам.ошибка.Коорд("Нарушение окончания имени модуля, слово="+слово.имя, слово.коорд)
		# Обрезать заголовок модуля
		счёт_новый = 0
		слова = {}
		for счёт in сам.__слова:
			if счёт > 2:
				слово = сам.__слова[счёт]
				слово._Номер_Уст(счёт_новый)
				слова[счёт_новый] = слово
				счёт_новый += 1
		сам.__слова = слова

	def Модуль_Конец(сам):
		"""
		Вычисляет окончание модуля.
		"""
		тег_счёт = len(сам.__слова)-1
		while тег_счёт > -1:
			слово = сам.__слова[тег_счёт]
			assert type(слово) == тСлово, "Слово должно быть тСлово, type="+type(слово)
			if слово.строка == "." and сам.__слова[тег_счёт-2].строка == "END": # Между ними -- возможно имя модуля
				if сам.__слова[тег_счёт-1].строка == сам.__имя:
					сам.__конец = сам.__слова[тег_счёт-2].номер
					break
				else: # имя модуля в начале и конце -- не совпало
					сам.ошибка.Коорд("Имя модуля не совпадает, слово="+сам.__слова[тег_счёт-1].имя, \
								сам.__слова[тег_счёт-1].коорд)
			тег_счёт -= 1
		if тег_счёт == -1:
			сам.ошибка.Печать("Нет окончания модуля "+сам.__имя)

		# теперь отбросим окончание модуля.
		счёт_новый = 0
		слова = {}
		for счёт in сам.__слова:
			if счёт < сам.__конец:
				слово = сам.__слова[счёт]
				слово._Номер_Уст(счёт_новый)
				слова[счёт_новый] = слово
				счёт_новый += 1
		сам.__слова = слова

	def Модуль_Один(сам):
		# Слово MODULE должно быть одно.
		счётчик_модуль = 0
		for номер_тега in сам.__слова:
			слово = сам.__слова[номер_тега]
			assert type(слово) == тСлово, "Слово должно быть тСлово, type="+type(слово)
			if слово.строка == "MODULE":
				счётчик_модуль += 1
				if счётчик_модуль > 1:
					сам.ошибка.Коорд("MODULE в файле должно быть только один раз!", слово.коорд, слово.стр)

	def Модуль_BEGIN(сам):
		'''
		Контроль на наличие секции BEGIN в модуле.
		Просматриваем модуль снизу вверх до первого BEGIN
		'''
		счёт_тег = len(сам.__тег)-1
		while счёт_тег >= 0:
			"""
			#TODO: тут нужно доделать обработку.
			Да и с неё надо бы начать.
			"""

	def Модуль_Контроль(сам):  # Проверить правильность объявления модуля.
		'''
		Контроль на правильное открытие и закрытие модуля.
		'''
		сам.Модуль_Первый()
		сам.Имя_Второе()
		сам.Заголовок_Конец()
		сам.Модуль_Конец()
		сам.Модуль_Один()

	def Слова_Печать(сам):
		print("\nтМодуль.Слова_Печать() "+сам.__имя)
		for ключ in сам.__слова:
			слово = сам.__слова[ключ]
			print(слово)

	def Секции_Разбить(сам):
		'''
			Разбитие на глобальные секции:
			MODULE
				IMPORT
				CONST
				TYPE
				VAR
				PROCEDURE
			BEGIN [module]
			END [module]
		'''
		сам.__импорт = тИмпорт(сам)
		сам.__слова = {}
		сам.__слова = сам.__импорт.слова_модуль

		сам.__конст = тКонстанты(сам)
		сам.__слова = {}
		сам.__слова = сам.__конст.слова_модуля

		сам.__типы = тТипы(сам)
		сам.__слова = {}
		сам.__слова = сам.__типы.слова_модуля

		сам.__перем = тПеременные(сам)
		сам.__слова = {}
		сам.__слова = сам.__перем.слова_модуля

		сам.__проц = тПроцедуры(сам.__корень, сам.__слова)
		сам.__проц.Обработать()
		сам.__слова = {}
		сам.__слова = сам.__проц.слова_секции

	def Обработать(сам):
		сам.Модуль_Контроль()
		#сам.Слова_Печать()
		сам.Секции_Разбить()

	@property
	def имя(сам):
		return сам.__имя

	@property
	def слова(сам):
		return сам.__слова

	@property
	def конс(сам):
		return сам.__конс

	@property
	def ошибка(сам):
		сам.__ошибка
