# coding:utf8
"""
Содержит базовый тип для всех родов записей
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	
class тТипБазовый:
	def __init__(сам, пКорень, пСловаСекции):
		assert пКорень != None, "Корень компилятора не может быть None"
		сам.__корень = пКорень
		сам.ошибка = пКорень.ошибка
		сам.консоль = пКорень.конс
		
		assert len(пСловаСекции) > 1, "тТипБазовый: Неполное определение секции"
		сам.__слова_секции = пСловаСекции # Список слов типа
		сам.__бЭкспорт = False # признак экспорта
		сам.__стрИмя = ""
		сам.__Имя_Получить()
		сам.__Экспорт_Проверить()
		сам.__Определитель_Проверить()
	
	def Ошибка_Печать(сам, пСлово, пСообщ):
		строка_исх = сам.__корень.исх.строки(пСлово.коорд.стр)
		сам.консоль.Печать(сам.__корень.исх.строки(пСлово.коорд.стр))
		сам.ошибка.Коорд(пСообщ, пСлово.коорд, пСлово.строка)
		
	def __Имя_Получить(сам):
		стрИмя = сам.__слова_секции[0]
		assert стрИмя != тСлово, "тТипБазовый: Имя типа должно быть тСлово, тип= " + str(type(стрИмя))
		assert стрИмя.строка != "", "тТипБазовый: Имя типа не должно быть пыстым!"
		сам.__стрИмя = стрИмя.строка # имя типа
		print("тТипБазовый: имя_типа=", сам.__стрИмя)
		сам.СловаСекции_Обрезать()
	
	def __Определитель_Проверить(сам):
		"""
		Проверяет является ли слово в начале слов секции типа -- "=".
		После обрезания, должно быть первым.
		"""
		слово_опр = сам.__слова_секции[0]

		assert слово_опр != тСлово, "тТипБазовый: определитель типа '=' должен быть тСлово, тип="+str(type(слово_опр))
		assert слово_опр.строка != "", "тТипБазовый: определитель типа '=' не может быть пустым!"

		if слово_опр.строка == "=": # если определение типа
			сам.СловаСекции_Обрезать()
		else: # нарушение выражения
			сам.Ошибка_Печать(слово_опр, "тТипБазовый: Отсутствует определитель (=) в объявлении типа")
	
	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.__слова_секции)):
			новый_список[ключ-1]=сам.__слова_секции[ключ]
		сам.__слова_секции = {}
		сам.__слова_секции = новый_список
	
	def Двоеточие_Обрезать(сам):
		слово_двоеточ = сам.__слова_секции[0]
		assert слово_двоеточ != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_двоеточ))
		строка_двоеточ = слово_двоеточ.строка
		assert строка_двоеточ != "", "тТип: поле записи должно разделяться ':' строка=" + строка_двоеточ
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()
			бВыход = True
		else:
			бВыход = False
		return бВыход
	
	def ЗаписьКонец_Обрезать(сам):
		слово_конец = сам.__слова_секции[0]
		assert слово_конец != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_конец))
		строка_конец = слово_конец.строка
		assert строка_конец != "", "тТип: окончание записи не может быть пустым"
		if строка_конец == "END": # есть окончание
			сам.СловаСекции_Обрезать()
			бВыход = True
		else:
			бВыход = False
		return бВыход
	
	def Разделитель_Обрезать(сам):
			слово_раздел = сам.__слова_секции[0]
			assert слово_раздел != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_раздел))
			строка_раздел = слово_раздел.строка
			assert строка_раздел != "", "тТип: разделитель записи не может быть пустым"
			if строка_раздел == ";": # закрытие имени предка
				сам.СловаСекции_Обрезать()
			else:
				сам.Ошибка_Печать(слово_раздел, "тТипБазовый: отсутствует определитель (=) в объявлении типа")
				assert False, "тТип: пропущен разделитель записи?"
	
	def __Экспорт_Проверить(сам):
		"""
		Проверяет является литип экспортируемым.
		"""
		слово_экспорт = сам.__слова_секции[0]
		assert type(слово_экспорт) == тСлово, "тТип: Признак экспорта должен быть тСлово, тип= " + str(type(слово_экспорт))
		assert слово_экспорт.строка != "", "тТип: Обозначение экспорта типа или определения не может быть пустой строкой"
		if слово_экспорт.строка == "*": # есть экспорт
			сам.__бЭкспорт = True
			сам.СловаСекции_Обрезать()
		print("      экспорт =", сам.__бЭкспорт)
	
	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт
	
	@property
	def слова_секции(сам):
		return сам.__слова_секции
	
	@property
	def имя(сам):
		return сам.__имя
