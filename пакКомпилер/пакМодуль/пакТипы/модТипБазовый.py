# coding:utf8
"""
Содержит базовый тип для всех родов записей
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакТипы import модРод as мРод

class тТипБазовый:
	def __init__(сам, пКорень, пСловаСекции):
		assert пКорень != None, "Корень компилятора не может быть None"
		сам.__корень = пКорень
		сам.ошибка = пКорень.ошибка
		сам.консоль = пКорень.конс

		assert len(пСловаСекции) > 1, "тТипБазовый: Неполное определение секции"
		сам.__слова_секции = пСловаСекции # Список слов типа
		сам.__бЭкспорт = False # признак экспорта
		сам.__стрИмя = ""
		сам.__род = мРод.сБезРода # Род типа -- встроенный, POINTER, ARRAY, RECORD, PROCEDURE
		сам.__предок = "" # предок текущего типа

		сам.__Имя_Получить()
		сам.__Экспорт_Проверить()
		сам.__Определитель_Проверить()
		сам.__Род_Проверить()

	def Ошибка_Печать(сам, пСлово, пСообщ):
		строка_исх = сам.__корень.исх.строки(пСлово.коорд.стр)
		сам.консоль.Печать(сам.__корень.исх.строки(пСлово.коорд.стр))
		сам.ошибка.Коорд(пСообщ, пСлово.коорд, пСлово.строка)

	def __Имя_Получить(сам):
		стрИмя = сам.__слова_секции[0]
		assert стрИмя != тСлово, "тТипБазовый: Имя типа должно быть тСлово, тип= " + str(type(стрИмя))
		assert стрИмя.строка != "", "тТипБазовый: Имя типа не должно быть пыстым!"
		сам.__стрИмя = стрИмя.строка # имя типа
		print("тТипБазовый: имя_типа=", сам.__стрИмя)
		сам.СловаСекции_Обрезать()

	def __Определитель_Проверить(сам):
		"""
		Проверяет является ли слово в начале слов секции типа -- "=".
		После обрезания, должно быть первым.
		"""
		слово_опр = сам.__слова_секции[0]

		assert слово_опр != тСлово, "тТипБазовый: определитель типа '=' должен быть тСлово, тип="+str(type(слово_опр))
		assert слово_опр.строка != "", "тТипБазовый: определитель типа '=' не может быть пустым!"

		if слово_опр.строка != "=": # нарушение выражения
			сам.Ошибка_Печать(слово_опр, "тТипБазовый: Отсутствует определитель (=) в объявлении типа")
		else: # если определение типа
			сам.СловаСекции_Обрезать()

	def __Род_Проверить(сам):
		"""
		Устанавливает род типа:
		1. Алиас встроенного типа
		2. Массив
		3. Запись
		4. Указатель
		5. Процедура
		Обрезать слова секции нельзя. Иначе потом не узнаем
		какой тип алиаса используется.
		"""
		тип_встроен = ["BOOLEAN", "CHAR", "INTEGER", "REAL", "BYTE", "SET"]
		строка_род = сам.Слово_Проверить()
		if строка_род in тип_встроен:
			сам.__род = мРод.сВстроен
		elif строка_род == "ARRAY":
			сам.__род = мРод.сМассив
		elif строка_род == "RECORD":
			сам.__род = мРод.сЗапись
		elif строка_род == "POINTER":
			сам.__род = мРод.сУказатель
		elif строка_род == "PROCEDURE":
			сам.__род = мРод.сПроцедура
		else:
			assert False, "тТипБазовый: Неизвестный род типа, род="+строка_род

	@property
	def предок(сам):
		return сам.__предок

	def Предок_Уст(сам, пПредок):
		assert type(пПредок) == str, "тТипБазовй: пПредок должен быть str, type="+str(type(пПредок))
		assert пПредок != "", "тТипБазовый: пПредок не может быть пустой строкой"
		assert сам.__предок == "", "тТипБазовый: предок типа уже установлен, предок="+сам.__предок
		сам.__предок = пПредок

	def Слово_Проверить(сам):
		"""
		Проверяет первое слово в словаре слов секции на допустимость.
		"""
		слово = сам.слова_секции[0]
		assert type(слово) == тСлово, "тТипБазовый: слово должно быть тСлово, тип="+str(type(слово))
		строка = слово.строка
		assert type(строка) == str, "тТипБазовый: строка должна быть 'str', type=" + str(type(строка))
		assert строка != "", "тТипБазовый: строка не может быть пустой"
		return строка

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.__слова_секции)):
			новый_список[ключ-1]=сам.__слова_секции[ключ]
		сам.__слова_секции = {}
		сам.__слова_секции = новый_список

	def Двоеточие_Обрезать(сам):
		слово_двоеточ = сам.__слова_секции[0]
		assert слово_двоеточ != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_двоеточ))
		строка_двоеточ = слово_двоеточ.строка
		assert строка_двоеточ != "", "тТип: поле записи должно разделяться ':' строка=" + строка_двоеточ
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()
			бВыход = True
		else:
			бВыход = False
		return бВыход

	def ЗаписьКонец_Обрезать(сам):
		слово_конец = сам.__слова_секции[0]
		assert слово_конец != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_конец))
		строка_конец = слово_конец.строка
		assert строка_конец != "", "тТип: окончание записи не может быть пустым"
		if строка_конец == "END": # есть окончание
			сам.СловаСекции_Обрезать()
			бВыход = True
		else:
			бВыход = False
		return бВыход

	def Разделитель_Обрезать(сам):
			строка_раздел = сам.Слово_Проверить()
			if строка_раздел == ";": # закрытие имени предка
				сам.СловаСекции_Обрезать()
			else:
				assert False, "тТип: пропущен разделитель ';' типа? строка="+строка_раздел

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является литип экспортируемым.
		"""
		слово_экспорт = сам.__слова_секции[0]
		assert type(слово_экспорт) == тСлово, "тТип: Признак экспорта должен быть тСлово, тип= " + str(type(слово_экспорт))
		assert слово_экспорт.строка != "", "тТип: Обозначение экспорта типа или определения не может быть пустой строкой"
		if слово_экспорт.строка == "*": # есть экспорт
			сам.__бЭкспорт = True
			сам.СловаСекции_Обрезать()
		print("      экспорт =", сам.__бЭкспорт)

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	@property
	def слова_секции(сам):
		return сам.__слова_секции

	@property
	def имя(сам):
		return сам.__имя

	@property
	def род(сам):
		return сам.__род

	@property
	def корень(сам):
		return сам.__корень
