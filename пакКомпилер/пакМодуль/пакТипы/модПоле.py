# coding:utf8
"""
Модуль описывает поле ранее описанного типа в составе записи.
"""
if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакТипы.модРод import тРод

class тПоле:
	def __init__(сам, пТипЗапись):
		сам.тип = пТипЗапись.тип  # ссылка на тТип
		сам.запись = пТипЗапись   # ссылка на тТипЗапись
		сам.__поле_имя = ""
		сам.__поле_тип = ""
		сам.__поле_словарь =  {} # если вдруг поле окажется составным
		сам.__бЭкспорт = False
		сам.__Имя_Получить()
		сам.__Экспорт_Проверить()
		# проверка на простое поле или запись
		if сам.тип.Двоеточие_Обрезать():
			# начало фиксированного поля
			сам.__ТипПоля_Проверить()
			сам.тип.Разделитель_Обрезать()
		else: # здесь нужно обработать запись-структуру
			pass # TODO: доделать проверку на внутреннюю структуру

	def __Имя_Получить(сам):
		"""
		Получает имя поля.
		"""
		слово_поле = сам.тип.слова_секции[0]
		assert слово_поле != тСлово, "тПоле: имя поля должно быть тСлово, тип="+str(type(слово_поле))
		if слово_поле.ЕслиИмя():
			сам.__поле_имя = сам.тип.Слово_Проверить()
			сам.тип.СловаСекции_Обрезать()
			print("      Поле: имя= ", сам.__поле_имя)
		else:
			assert False, "Имя поля внутри типа должно быть именем, " + слово_поле.строка

	def __ТипПоля_Проверить(сам):
			"""
			Пытается вычислить поле в простой записи.
			слово тип может быть как встроенным, так и определяемое пользователем.
			"""
			строка_тип = сам.тип.Слово_Проверить()
			if строка_тип in тРод.тип_встроен:
				if строка_тип == "BOOLEAN":
					сам.__поле_тип = "BOOLEAN"
				elif строка_тип == "CHAR":
					сам.__поле_тип = "CHAR"
				elif строка_тип == "INTEGER":
					сам.__поле_тип = "INTEGER"
				elif строка_тип == "REAL":
					сам.__поле_тип = "REAL"
				elif строка_тип == "BYTE":
					сам.__поле_тип = "BYTE"
				elif строка_тип == "SET":
					сам.__поле_тип = "SET"
				else:
					assert False, "Неверный встроенный тип, строка=" + строка_тип
			elif строка_тип == "ARRAY":
				сам.__поле_тип = "ARRAY"
			слово_тип = сам.тип.слова_секции[0]
			assert слово_тип != тСлово, "тТипЗапись: слово поля должно быть тСлово, тип="+str(type(слово_тип))
			# здесь на имя слово проверять не надо. Это тип.
			if слово_тип.ЕслиИмя():
				сам.__поле_тип = сам.тип.Слово_Проверить()
				сам.тип.СловаСекции_Обрезать()
			else:
				assert False, "тПоле: Тип поля внутри записи должно быть именем, " + слово_тип.строка
			print("              тип =", сам.__поле_тип)
	
	def __Экспорт_Проверить(сам):
		"""
		Проверяет является ли тип экспортируемым.
		Эта процедура продублирована из тТипБазовый, так как
		у поля свой признак экспорта, а типа свой.
		"""
		строка_экспорт = сам.тип.Слово_Проверить()
		if строка_экспорт == "*": # есть экспорт
			сам.тип.СловаСекции_Обрезать()
			сам.__бЭкспорт = True
		elif строка_экспорт == "=":
			pass # это определение внутреннего типа TODO: доделать определение внутреннего типа
		elif строка_экспорт == ":":
			pass # это определение внутреннего поля
		else:
			assert False, "тПоле: Символ экспорта допустим '*' или '=',    строка=" + строка_экспорт
		print("          экспорт =", сам.__бЭкспорт)
