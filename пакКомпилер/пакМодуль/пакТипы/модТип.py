# coding: utf8
"""
Модуль предоставляет класс для разбора типа.
Простой тип может содержать определения других подтипов и членов.
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакТипы import модРод as мРод
	from . модПоле import тПоле
	from . модТипБазовый import тТипБазовый
	from . модТипАлиас import тТипАлиас
	from . модТипМассив import тТипМассив
	from . модТипЗапись import тТипЗапись

class тТип(тТипБазовый):
	def __init__(сам, пКорень, пСловаСекции):
		тТипБазовый.__init__(сам, пКорень, пСловаСекции)

		сам.массив_размерность = {} # заполняется при определении массива
		сам.запись_поля = {} # словарь полей типа RECORD
		сам.__РодТипа_Проверить()

	def __РодТипа_Проверить(сам):
		"""
		Проверяет род встреченного типа. Возможны варианты:
		1. Алиас встроенного типа.

		2.Массив чего-либо

		3. Пустая запись, должна заканчиваться "END;" (просто запись без членов -- бесполезна,
			но для расширения в шине сообщений -- бывает может пригодиться), скорей всего с
			множеством полей.

		4. Запись с полями, множественные уровни вложенности. Рекурсивный анализ.
			Заканчивается на "END;", но после слова "RECORD" идёт не "END"

		5. ....
		"""
		if сам.род == мРод.сВстроен: # текущий тип основан на встроенном типе
			алиас = тТипАлиас(сам)
		elif сам.род == мРод.сМассив: # текущий тип основан на массиве
			массив = тТипМассив(сам)
		elif сам.род == мРод.сЗапись: # текущий тип основан на записе
			запись = тТипЗапись(сам)
			сам.__ЗаписьПусто_Проверить()
		elif сам.род == мРод.сЗаписьСложная: # тип был не пустая запись НЕТ ТАКОГО ТИПА
			# здесь уже должно быть первое имя типа
			# все остальные поля предварительно заполнены
			сам.__Запись_Проверить()
		else:
			assert False, "тТип: неизвестный род записи, род=" + сам.род
		сам.Паспорт_Печать()


	def __ЗаписьПусто_Проверить(сам):
		"""
		Тип может быть пустой записью.
		Бывает полезно при расширении исходной записи.
		"""
		def ЕслиЗапись():
			строка = сам.Слово_Проверить()
			if строка == "RECORD":
				сам.СловаСекции_Обрезать()
				бВыход = True
			else:
				бВыход = False
			return бВыход
		if ЕслиЗапись():
			if сам.ЗаписьКонец_Обрезать():
				сам.Разделитель_Обрезать()

				#сам.__род = мРод.сЗаписьПусто
				#сам.__предок = мРод.сБезПредка
			else:
				#сам.__род = мРод.сЗаписьСложная
				pass

	def Слово_Доб(сам, пСлово):
		бУсл = type(пСлово) == тСлово
		стрОш = "В слова типа можно добавить только тСлово, type="+str(type(пСлово))
		сам.__корень.конс.Контроль(бУсл, стрОш)

		сам.__слова[len(сам.__слова)] = пСлово

	def Паспорт_Печать(сам):
		print("      род     =", сам.род)
		print("      предок  =", сам.предок)
		if сам.род == мРод.сМассив:
			for ключ in range(len(сам.массив_размерность)):
				print("      ключ ", ключ, ":",сам.массив_размерность[ключ])
			print("      элем    =", сам.массив_тип)
		if сам.род == мРод.сЗапись:
			for ключ in range(len(сам.запись_поля)):
				print("      ключ ", ключ, ":   ",сам.массив_размерность["имя"], "   тип=", сам.массив_размерность["тип"])
		print()
