# coding: utf8
"""
Модуль предоставляет класс для разбора типа.
Простой тип может содержать определения других подтипов и членов.
"""

if True:
	from пакКомпилер.пакСлово import тСлово

class тТип:
	цУказатель = 1
	цМассив    = 2
	цЗапись    = 3
	def __init__(сам, пКорень, псИмя, пСловаСекции):
		assert пКорень != None, "тТип: Корневая привязка не может быть None"
		сам.__корень = пКорень

		assert псИмя != тСлово, "тТип: Имя типа должно быть тСлово, тип= " + str(type(псИмя))
		assert псИмя.строка != "", "тТип: Имя типа не должно быть пыстым!"
		сам.__стрИмя = "" # имя типа

		assert len(пСловаСекции) > 1, "тТип: Неполное определение секции"
		сам.__слова_секции = пСловаСекции[1:] # Список слов типа
		сам.__род = 0 # Род типа -- POINTER TO, ARRAY, RECORD
		сам.__предок = "" # имя предка
		сам.__бЭкспорт = "" # признак экспорта
		сам.__Экспорт_Проверить()

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является литип экспортируемым.
		"""
		слово_эспорт = сам.__слова_секции[0]
		assert type(слово_эксопрт) == тСлово, "тТип: Признак экспорта должен быть тСлово, тип= " + str(type(слово_экспорт))
		assert слово_экспорт.строка != "", "тТип: Обозначение экспорта типа или определения не может быть пустой строкой"
		if слово_экспорт.строка == "*": # есть экспорт
			сам.__бЭкспорт = True
			сам.__слова__секции.delete(слово_экспорт)

	@property
	def имя(сам):
		return сам.__имя

	@property
	def предок(сам):
		return сам.__предок

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	@property
	def слова(сам):
		return сам.__слова

	def Слово_Доб(сам, пСлово):
		бУсл = type(пСлово) == тСлово
		стрОш = "В слова типа можно добавить только тСлово, type="+str(type(пСлово))
		сам.__корень.конс.Контроль(бУсл, стрОш)

		сам.__слова[len(сам.__слова)] = пСлово
