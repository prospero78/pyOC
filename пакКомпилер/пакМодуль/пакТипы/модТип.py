# coding: utf8
"""
Модуль предоставляет класс для разбора типа.
Простой тип может содержать определения других подтипов и членов.
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакТипы import модРод as мРод
	from . модПоле import тПоле

class тТип:
	def __init__(сам, пКорень, пСловаСекции):
		assert пКорень != None, "тТип: Корневая привязка не может быть None"
		сам.__корень = пКорень
		сам.ошибка = пКорень.ошибка

		assert len(пСловаСекции) > 1, "тТип: Неполное определение секции"
		сам.__слова_секции = пСловаСекции # Список слов типа

		стрИмя = пСловаСекции[0]
		assert стрИмя != тСлово, "тТип: Имя типа должно быть тСлово, тип= " + str(type(стрИмя))
		assert стрИмя.строка != "", "тТип: Имя типа не должно быть пыстым!"
		сам.__стрИмя = стрИмя.строка # имя типа
		print("тТип: имя_типа=", сам.__стрИмя)
		сам.__СловаСекции_Обрезать()


		сам.__род = мРод.сБезРода # Род типа -- встроенный, POINTER TO, ARRAY, RECORD
		сам.__предок = "" # имя предка
		сам.__бЭкспорт = False # признак экспорта
		сам.__массив_размерность = {} # заполняется при определении массива
		сам.__запись_поля = {} # словарь полей типа RECORD
		сам.__Экспорт_Проверить()
		сам.__Определитель_Проверить()
		сам.__РодТипа_Проверить()

	def __СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.__слова_секции)):
			новый_список[ключ-1]=сам.__слова_секции[ключ]
		сам.__слова_секции = {}
		сам.__слова_секции = новый_список

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является литип экспортируемым.
		"""
		слово_экспорт = сам.__слова_секции[0]
		assert type(слово_экспорт) == тСлово, "тТип: Признак экспорта должен быть тСлово, тип= " + str(type(слово_экспорт))
		assert слово_экспорт.строка != "", "тТип: Обозначение экспорта типа или определения не может быть пустой строкой"
		if слово_экспорт.строка == "*": # есть экспорт
			сам.__бЭкспорт = True
			сам.__СловаСекции_Обрезать()
		print("      экспорт =", сам.__бЭкспорт)

	def __Определитель_Проверить(сам):
		"""
		Проверяет является ли слово в начале слов секции типа -- "=".
		После обрезания, должно быть первым.
		"""
		слово_опр = сам.__слова_секции[0]

		assert слово_опр != тСлово, "тТип: должно быть тСлово, тип="+str(type(слово_опр))
		assert слово_опр.строка != "", "тТип: определение типа не может быть пустым!"

		if слово_опр.строка == "=": # если определение типа
			сам.__СловаСекции_Обрезать()
		else: # нарушение выражения
			строка_исх = сам.__корень.исх.строки(слово_опр.коорд.стр)
			print(сам.__корень.исх.строки(слово_опр.коорд.стр), строка_исх)
			сам.ошибка.Коорд("тТип: Отсутствует определитель (=) в объявлении типа", слово_опр.коорд, слово_опр.строка)

	def __РодТипа_Проверить(сам):
		"""
		Проверяет род встреченного типа. Возможны варианты:
		1. Алиас встроенного типа.

		2.Массив чего-либо

		3. Пустая запись, должна заканчиваться "END;" (просто запись без членов -- бесполезна,
			но для расширения в шине сообщений -- бывает может пригодиться), скорей всего с
			множеством полей.

		4. Запись с полями, множественные уровни вложенности. Рекурсивный анализ.
			Заканчивается на "END;", но после слова "RECORD" идёт не "END"

		5. ....
		"""
		сам.__Алиас_Проверить()
		if сам.__род == мРод.сБезРода: # текущий тип не базового рода
			сам.__Массив_Проверить()
		if сам.__род == мРод.сБезРода: # тип был не массив
			сам.__ЗаписьПусто_Проверить()
		if сам.__род == мРод.сЗаписьСложная: # тип был не пустая запись
			# здесь уже должно быть первое имя типа
			# все остальные поля предварительно заполнены
			сам.__Запись_Проверить()
		сам.Паспорт_Печать()

	def __Запись_Проверить(сам):
		"""
		Проверяет сложную структуру записи.
		Может иметь множество полей и вложенных записей.
		Запись уже проверена на имя, и слово[0] содержит "("
		"""
		def Предок_Получ():
				слово_предок = сам.__слова_секции[0]
				assert слово_предок != тСлово, "тТип: слово-предок должно быть тСлово, тип="+str(type(слово_предок))
				строка_предок = слово_предок.строка
				assert строка_предок != str, "тТип: слово-предок должно быть str, тип="+str(type(строка_предок))
				assert строка_предок != "", "тТип: предок записи не может быть пустым"
				сам.__предок = строка_предок
				сам.__СловаСекции_Обрезать()
		def СкобкаЛевая_Обрезать():
			"""
			Скобка слева уже проверена, что она есть в тТип.ЗаписьПусто_Проверить()
			"""
			сам.__СловаСекции_Обрезать()
		def СкобкаПрав_Обрезать():
				слово_скобка = сам.__слова_секции[0]
				assert слово_скобка != тСлово, "тТип: слово скобка должно быть тСлово, тип="+str(type(слово_скобка))
				строка_скобка = слово_скобка.строка
				assert строка_скобка != str, "тТип: скобка справа предка записи должен быть str, "+str(type(строка_скобка))
				assert строка_скобка != "", "тТип: скобка справа предок записи не может быть пустым"
				if строка_скобка == ")": # закрытие имени предка
					сам.__СловаСекции_Обрезать()
				else:
					assert False, "тТип: пропущена закрывающая скобка предка? \""+строка_скобка+"\""
		def ИмяПоля_Проверить():
			"""
			Пытается вычислить все поля в сложной записи.
			"""
			слово_поле = сам.__слова_секции[0]
			assert слово_поле != тСлово, "тТип: слово поля должно быть тСлово, тип="+str(type(слово_род))
			if слово_поле.ЕслиИмя():
				строка_поле = слово_поле.строка
				assert строка_поле != "", "тТип: строка поля не может быть пустой"
				сам.__СловаСекции_Обрезать()
				return строка_поле
			else:
				assert False, "Имя поля в определении типа должно быть именем, " + слово_поле.строка
		def ТипПоля_Проверить():
			"""
			Пытается вычислить все поля в сложной записи.
			"""
			слово_тип = сам.__слова_секции[0]
			assert слово_тип != тСлово, "тТип: слово поля должно быть тСлово, тип="+str(type(слово_тип))
			if слово_тип.ЕслиИмя():
				строка_тип = слово_тип.строка
				assert строка_тип != "", "тТип: строка поля не может быть пустой"
				сам.__СловаСекции_Обрезать()
				return строка_тип
			else:
				assert False, "Имя поля в определении типа должно быть именем, " + слово_поле.строка
		СкобкаЛевая_Обрезать()
		Предок_Получ()
		СкобкаПрав_Обрезать()
		if сам.__ЗаписьКонец_Обрезать():
			сам.__Разделитель_Обрезать()
			print("Это пустая запись с предком")
		else:
			# проверяем поле на имя
			строка_поле = ИмяПоля_Проверить()
			# строка уже проверена на допустимость имени
			поле = {}
			поле["имя"] = строка_поле
			if сам.__Двоеточие_Обрезать():
				# это точно поле
				строка_тип = ТипПоля_Получить()
				поле['тип'] = строка_тип
				сам.__запись_поля[len(сам.__запись_поля)] = поле
				сам.__Разделитель_Обрезать()


	def __ЗаписьПусто_Проверить(сам):
		"""
		Тип может быть пустой записью.
		Бывает полезно при расширении исходной записи.
		"""
		def ЕслиЗапись():
			слово_род = сам.__слова_секции[0]
			assert слово_род != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_род))
			строка = слово_род.строка
			assert строка != "", "тТип: тип записи не может быть пустым"
			if строка == "RECORD":
				сам.__СловаСекции_Обрезать()
				бВыход = True
			else:
				бВыход = False
			return бВыход
		if ЕслиЗапись():
			if сам.__ЗаписьКонец_Обрезать():
				сам.__Разделитель_Обрезать()

				сам.__род = мРод.сЗаписьПусто
				сам.__предок = мРод.сБезПредка
			else:
				сам.__род = мРод.сЗаписьСложная

	def __Массив_Проверить(сам):
		"""
		Пытается проверить, является ли тип массивом.
		"""
		def Размерности_Получить():
			"""
			Рекурсивно получает и заполняет размерности массива.
			"""
			сам.__СловаСекции_Обрезать()
			# получаем первую размерность массива
			слово_число1 = сам.__слова_секции[0]
			assert слово_число1 != тСлово, "тТип: число массива должно быть тСлово, тип="+str(type(слово_число1))
			try:
				число1 = int(слово_число1.строка)
			except:
				assert False, "тТип: число массива должно быть числом, тип="+str(type(число1))
			сам.__массив_размерность[len(сам.__массив_размерность)]=число1
			сам.__СловаСекции_Обрезать()
			# есть ли ещё размерности
			слово_запятая = сам.__слова_секции[0]
			assert слово_запятая != тСлово, "тТип: разделитель размерностей массива должен быть тСлово, тип="+str(type(слово_запятая))
			запятая = слово_запятая.строка
			if запятая == ",": # есть ещё размерности
				Размерности_Получить()
		слово_род = сам.__слова_секции[0]
		assert слово_род != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_род))
		строка = слово_род.строка
		assert строка != "", "тТип: строка не может быть пустой"
		if строка == "ARRAY":
			сам.__род = мРод.сВстроен
			сам.__предок = "ARRAY"
			Размерности_Получить()
			# сейчас слово должно быть OF
			слово_из = сам.__слова_секции[0]
			assert слово_из != тСлово, "тТип: слово OF в описании массива должно быть тСлово, тип="+str(type(слово_из))
			строка = слово_из.строка
			assert строка != "", "тТип: строка не может быть пустой"
			if строка != "OF":
				assert False, "тТип: пропущено OF в определении массива? слово="+строка
			сам.__СловаСекции_Обрезать()
			слово_тип = сам.__слова_секции[0]
			assert слово_тип != тСлово, "тТип: слово типа в описании массива должно быть тСлово, тип="+str(type(слово_тип))
			строка_тип = слово_тип.строка
			assert строка != "", "тТип: элементы типа массива не могут быть пустой строкой"
			сам.__массив_тип = строка_тип
			сам.__СловаСекции_Обрезать()
			# теперь ковыряем разделитель
			слово_раздел = сам.__слова_секции[0]
			assert слово_раздел != тСлово, "тТип: слово разделителя в описании массива должно быть тСлово, тип="+str(type(слово_раздел))
			строка_раздел = слово_раздел.строка
			assert строка_раздел != "", "тТип: строка разделителя массива не может быть пустой строкой"
			if строка_раздел != ";":
				assert False, "тТип: пропущен разделитель в определении массива? слово="+строка_раздел
			сам.__СловаСекции_Обрезать()

	def __Алиас_Проверить(сам):
		"""
		Проверяет не является ли тип алиасом встроенного типа.
		"""
		тип_встроен = ["BOOLEAN", "CHAR", "INTEGER", "REAL", "BYTE", "SET"]
		слово_род = сам.__слова_секции[0]
		assert слово_род != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_род))
		if слово_род.строка in тип_встроен:
			сам.__род = мРод.сВстроен

			строка = слово_род.строка
			assert строка != str, "Род типа должен бть строкой, type="+str(type(строка))
			assert строка != "", "тТип: строка не может быть пустой, строка=" + строка

			if строка == "BOOLEAN":
				сам.__предок = "BOOLEAN"
			elif строка == "CHAR":
				сам.__предок = "CHAR"
			elif строка == "INTEGER":
				сам.__предок = "INTEGER"
			elif строка == "REAL":
				сам.__предок = "REAL"
			elif строка == "BYTE":
				сам.__предок = "BYTE"
			elif строка == "SET":
				сам.__предок = "SET"
			else:
				assert False, "тТип: неизвестный встроенный предок, " + строка
			# обрежем род типа
			сам.__СловаСекции_Обрезать()
			# проверим окончание определения типа
			слово_конец = сам.__слова_секции[0]
			assert слово_конец != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_род))
			строка = слово_конец.строка
			assert строка != "", "тТип: строка не может быть пустой, строка="+строка
			if строка == ";":
				сам.__СловаСекции_Обрезать()
			else:
				assert False, "Неправильное окончание определения алиаса встроенного типа"

	def __Разделитель_Обрезать(сам):
			слово_раздел = сам.__слова_секции[0]
			assert слово_раздел != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_раздел))
			строка_раздел = слово_раздел.строка
			assert строка_раздел != "", "тТип: разделитель записи не может быть пустым"
			if строка_раздел == ";": # закрытие имени предка
				сам.__СловаСекции_Обрезать()
			else:
				assert False, "тТип: пропущен разделитель записи?"

	def __ЗаписьКонец_Обрезать(сам):
		слово_конец = сам.__слова_секции[0]
		assert слово_конец != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_конец))
		строка_конец = слово_конец.строка
		assert строка_конец != "", "тТип: окончание записи не может быть пустым"
		if строка_конец == "END": # есть окончание
			сам.__СловаСекции_Обрезать()
			бВыход = True
		else:
			бВыход = False
		return бВыход

	def __Двоеточие_Обрезать(сам):
		слово_двоеточ = сам.__слова_секции[0]
		assert слово_двоеточ != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_двоеточ))
		строка_двоеточ = слово_двоеточ.строка
		assert строка_двоеточ != "", "тТип: поле записи должно разделяться ':' строка=" + строка_двоеточ
		if строка_двоеточ == ":": # есть двоеточие
			сам.__СловаСекции_Обрезать()
			бВыход = True
		else:
			бВыход = False
		return бВыход

	@property
	def имя(сам):
		return сам.__имя

	@property
	def предок(сам):
		return сам.__предок

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	@property
	def слова_секции(сам):
		return сам.__слова_секции

	@property
	def род(сам):
		return сам.__род

	def Слово_Доб(сам, пСлово):
		бУсл = type(пСлово) == тСлово
		стрОш = "В слова типа можно добавить только тСлово, type="+str(type(пСлово))
		сам.__корень.конс.Контроль(бУсл, стрОш)

		сам.__слова[len(сам.__слова)] = пСлово

	def Паспорт_Печать(сам):
		print("      род     =", сам.род)
		print("      предок  =", сам.__предок)
		if сам.__предок == "ARRAY":
			for ключ in range(len(сам.__массив_размерность)):
				print("      ключ ", ключ, ":",сам.__массив_размерность[ключ])
			print("      элем    =", сам.__массив_тип)
		print()
