# coding: utf8
"""
Модуль предоставляет класс для разбора типа.
Простой тип может содержать определения других подтипов и членов.
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакТипы.модРод import тРод

	from . модТипВстроен import тТипВстроен
	from . модТипМассив import тТипМассив
	from . модТипЗапись import тТипЗапись

	from пакКомпилер.пакМодуль.пакПоле.модПоле import тПоле

class тТип:
	def __init__(сам, пДанные):
		сам.слова_секции = пДанные['слова'] # Список слов типа
		сам.__имя = "" # Имя типа в установить в пустую строку
		сам.__бЭкспорт = False
		сам.__род = тРод.сБезРода # Род записи -- один из встроенных, ARRAY, RECORD, PROCEDURE
		сам.__предок = тРод.сБезТипа # Тип предка -- один из наследуемых
		сам.__бУказатель = False # тип имеет модификатор указатель
		сам.массив_тип = тРод.сБезТипа # устанавливает тип массива (если тип -- массив)
		сам.поля = {} # словарь полей типа
		assert len(сам.слова_секции) > 1, "тТипБазовый: Неполное определение секции"

		сам.массив_размерность = {} # заполняется при определении массива
		сам.запись_поля = {} # словарь полей типа RECORD
		сам.__Имя_Проверить()
		сам.__Экспорт_Проверить()
		сам.__Определитель_Проверить()
		сам.__Указатель_Проверить()
		сам.__Род_Проверить()
		сам.__Разделитель_Обрезать()

	def __Имя_Проверить(сам):
		"""
		Проверяет имя типа. Должно быть именем и
		не должно быть END.
		Имя НЕ МОЖЕТ быть составным
		"""
		бРезульт = False
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			сам.СловаСекции_Обрезать()
			сам.__имя = имя
			бРезульт = True
		else:
			assert False, "тТип: имя типа должно быть допустимым именем" + слово_имя.стрИсх

	def Предок_Проверить(сам):
		"""
		Проверяет предка записи. Должно быть разрешённой строкой и
		не должно быть END.
		Кроме того, имя может быть составным
		"""
		бРезульт = False
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		стрОш = "тТип: имя типа должно быть допустимым именем"
		assert слово_имя.ЕслиСтр_Допустимо(), стрОш + слово_имя.стрИмя
		assert сам.__предок == тРод.сБезТипа, "тТип: предок уже назначен, предок=" + сам.__предок
		сам.__предок = ""
		while (имя == ".") or (слово_имя.ЕслиСтр_Допустимо()):
			сам.СловаСекции_Обрезать()
			сам.__предок += имя
			слово_имя = сам.слова_секции[0]
			имя = слово_имя.Проверить()
			бРезульт = True
		return бРезульт

	def Элемент_Проверить(сам, пПоле):
		"""
		Проверяет предка записи. Должно быть разрешённой строкой и
		не должно быть END.
		Кроме того, имя может быть составным
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		стрОш = "тПеременные: тип элемента переменной должен быть допустимым именем"
		assert слово_имя.ЕслиСтр_Допустимо(), стрОш + слово_имя.стрИсх
		assert сам.массив_тип == тРод.сБезТипа, "тТип: элемент массива уже назначен, элемент=" + сам.массив_тип
		элемент = ""
		while (имя == ".") or (слово_имя.ЕслиСтр_Допустимо()):
			сам.СловаСекции_Обрезать()
			элемент += имя
			слово_имя = сам.слова_секции[0]
			имя = слово_имя.Проверить()
		return элемент

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является ли тип экспортируемым.
		"""
		слово_экспорт = сам.слова_секции[0]
		строка_экспорт = слово_экспорт.Проверить()
		if строка_экспорт == "*": # есть экспорт
			сам.СловаСекции_Обрезать()
			сам.__бЭкспорт = True
		elif строка_экспорт == "=":
			pass # это определение типа
		else:
			assert False, "тТип: Символ экспорта допустим '*' или '='" + слово_экспорт.стрИсх

	def __Определитель_Проверить(сам):
		"""
		Проверяет является ли слово в начале слов секции типа -- "=".
		После обрезания, должно быть первым.
		"""
		слово_опр = сам.слова_секции[0]
		строка_опр = слово_опр.Проверить()
		if слово_опр.род == тСлово.кРавно: # правильное выражение определения типа
			сам.СловаСекции_Обрезать()
		else: # если определение типа
			assert False, "тТип: Отсутствует определитель (=) в объявлении типа" + слово_опр.стрИсх

	def __Род_Проверить(сам):
		"""
		Проверяет род встреченного типа. Возможны варианты:
		1. Алиас встроенного типа.

		2.Массив чего-либо

		3. Пустая запись, должна заканчиваться "END;" (просто запись без членов -- бесполезна,
			но для расширения в шине сообщений -- бывает может пригодиться), скорей всего с
			множеством полей.

		4. Запись с полями, множественные уровни вложенности. Рекурсивный анализ.
			Заканчивается на "END;", но после слова "RECORD" идёт не "END"

		5. ....
		"""
		парам = {}
		парам['секция']=сам
		парам['слова']=сам.слова_секции
		слово_род = сам.слова_секции[0]
		строка_род = слово_род.Проверить()
		assert слово_род.ЕслиСтр_Допустимо(), "тТип: род типа должен быть допустимым именем" + слово_род.стрИсх
		if строка_род in тРод.тип_встроен: # текущий тип основан на встроенном типе
			тип = тТипВстроен(парам)
		elif строка_род == тРод.сМассив: # текущий тип основан на массиве
			тип = тТипМассив(парам)
		elif строка_род == тРод.сЗапись: # текущий тип основан на записе
			тип = тТипЗапись(парам)
			сам.__род = тРод.сЗапись
		elif строка_род == тРод.сПроцедура: # текущий тип основан на процедуре
			тип = тТипПроцедура(парам)
			сам.__род = тРод.сПроцедура
		elif сам.слова_секции[0].ЕслиСтр_Допустимо():
			"""
			Здесь конструкция вида:
			POINTER TO мЧт.Ввод
			Тип устанавливается вручную.
			"""
			сам.Предок_Проверить()
		else:
			assert False, "тТип: неизвестный тип записи" + слово_род.стрИсх

	def __Указатель_Проверить(сам):
		"""
		Если тип является указателем, то устанавливается соответствующий признак.
		Иначе, просто пропускается.
		"""
		слово_род = сам.слова_секции[0]
		строка_род = слово_род.Проверить()
		if строка_род in тРод.сУказатель: # модификатор типа, а не сам тип
			сам.__бУказатель = True
			сам.СловаСекции_Обрезать()
			# дальше ОБЯЗАТЕЛЬНО следует ключевое слово "TO"
			слово_из = сам.слова_секции[0]
			строка_из = слово_из.Проверить()
			if строка_из == "TO": # следование за POINTER
				сам.СловаСекции_Обрезать()
			else:
				assert False, "тТип: за POINTER не следует TO" + слово_из.стрИсх

	def __Разделитель_Обрезать(сам):
		"""
		В простых типах последнее слово ";"
		Поэтому его необходимо обрезать
		"""
		слово_раздел = сам.слова_секции[0]
		if слово_раздел.род == тСлово.кТочкаЗапятая:
			сам.СловаСекции_Обрезать()
		else:
			assert False, "тТип: неправильный разделитель типа" + слово_раздел.стрИсх

	def Предок_Уст(сам, пПредок):
		assert type(пПредок) == str, "тТип: пПредок должен быть str, type="+str(type(пПредок))
		assert пПредок != "", "тТип: пПредок не может быть пустой строкой"
		assert not (пПредок in "0123456789#!@%$^&*()-=+<>?/.`~№;:"), "Имя предка не может начинаться с этой литеры, пПредок=" + пПредок
		assert сам.__предок == тРод.сБезТипа, "тТип: тип уже установлен, тип="+сам.__предок
		сам.__предок = пПредок

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	@property
	def имя(сам):
		return сам.__имя

	@property
	def предок(сам):
		return сам.__предок

	def Паспорт_Печать(сам):
		print("тТип: имя_типа=", сам.__имя)
		print("      экспорт =", сам.__бЭкспорт)
		print("    указатель =", сам.__бУказатель)
		print("          предок =", сам.__предок)
		if сам.__род != тРод.сБезРода:
			print("             род =", сам.__род)
		if сам.__предок == тРод.сМассив:
			for ключ in range(len(сам.массив_размерность)):
				print("      ключ ", ключ, ":",сам.массив_размерность[ключ])
			print("      элем    =", сам.массив_тип)
		if сам.__предок == тРод.сЗапись:
			for ключ in range(len(сам.запись_поля)):
				сам.запись.поля[ключ].Паспорт_Печать()
		print()
