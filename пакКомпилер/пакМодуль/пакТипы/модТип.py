# coding: utf8
"""
Модуль предоставляет класс для разбора типа.
Простой тип может содержать определения других подтипов и членов.
"""

if True:
	from пакКомпилер.пакСлово import тСлово

class тТип:
	цБезРода, цВстроен, \
	цАлиас, цЗапись, цМассив, цУказатель = range(6)
	def __init__(сам, пКорень, пСловаСекции):

		assert пКорень != None, "тТип: Корневая привязка не может быть None"
		сам.__корень = пКорень
		сам.ошибка = пКорень.ошибка

		assert len(пСловаСекции) > 1, "тТип: Неполное определение секции"
		сам.__слова_секции = пСловаСекции # Список слов типа

		стрИмя = пСловаСекции[0]
		assert стрИмя != тСлово, "тТип: Имя типа должно быть тСлово, тип= " + str(type(стрИмя))
		assert стрИмя.строка != "", "тТип: Имя типа не должно быть пыстым!"
		сам.__стрИмя = стрИмя # имя типа
		сам.__СловаСекции_Обрезать()


		сам.__род = тТип.цБезРода # Род типа -- встроенный, POINTER TO, ARRAY, RECORD
		сам.__предок = "" # имя предка
		сам.__бЭкспорт = "" # признак экспорта
		сам.__массив_размерность = {} # заполняется при определении массива
		сам.__Экспорт_Проверить()
		сам.__Определитель_Проверить()
		сам.__РодТипа_Проверить()

	def __СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.__слова_секции)):
			новый_список[ключ-1]=сам.__слова_секции[ключ]
		сам.__слова_секции = {}
		сам.__слова_секции = новый_список

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является литип экспортируемым.
		"""
		слово_экспорт = сам.__слова_секции[0]
		assert type(слово_экспорт) == тСлово, "тТип: Признак экспорта должен быть тСлово, тип= " + str(type(слово_экспорт))
		assert слово_экспорт.строка != "", "тТип: Обозначение экспорта типа или определения не может быть пустой строкой"
		if слово_экспорт.строка == "*": # есть экспорт
			сам.__бЭкспорт = True
			сам.__СловаСекции_Обрезать()

	def __Определитель_Проверить(сам):
		"""
		Проверяет является ли слово в начале слов секции типа -- "=".
		После обрезания, должно быть первым.
		"""
		слово_опр = сам.__слова_секции[0]

		assert слово_опр != тСлово, "тТип: должно быть тСлово, тип="+str(type(слово_опр))
		assert слово_опр.строка != "", "тТип: определение типа не может быть пустым!"

		if слово_опр.строка == "=": # если определение типа
			сам.__СловаСекции_Обрезать()
		else: # нарушение выражения
			строка = сам.__корень.исх.строки(слово_опр.коорд.стр)
			print(сам.__корень.исх.строки(слово_опр.коорд.стр), строка)
			сам.ошибка.Коорд("тТип: Отсутствует определитель (=) в объявлении типа", слово_опр.коорд, строка)

	def __РодТипа_Проверить(сам):
		"""
		Проверяет род встреченного типа. Возможны варианты:
		1. Алиас встроенного типа.

		2. Просто запись, должна заканчиваться "END;" (просто запись без членов-- бесполезна,
		но для расширения в шине сообщений -- бывает может пригодиться), скорей всего с
		множеством полей.

		3. Ссылка на запись.

		4. ....
		"""
		сам.__Алиас_Проверить()
		if сам.__род == тТип.цБезРода: # текущий тип не базового рода
			сам.__Массив_Проверить()
			
	def __Массив_Проверить(сам):
		"""
		Пытается проверить, является ли тип массивом.
		"""
		def Размерности_Получить():
			"""
			Рекурсивно получает и заполняет размерности массива.
			"""
			сам.__СловаСекции_Обрезать()
			# получаем первую размерность массива
			слово_число1 = сам.__слова_секции[0]
			assert слово_число1 != тСлово, "тТип: число массива должно быть тСлово, тип="+str(type(слово_число1))
			try:
				число1 = int(слово_число1.строка)
			except:
				assert False, "тТип: число массива должно быть числом, тип="+str(type(число1))
			сам.__массив_размерность[len(сам.__массив_размерность)]=число1
			сам.__СловаСекции_Обрезать()
			# есть ли ещё размерности
			слово_запятая = сам.__слова_секции[0]
			assert слово_запятая != тСлово, "тТип: разделитель размерностей массива должен быть тСлово, тип="+str(type(слово_запятая))
			запятая = слово_запятая.строка
			if запятая == ",": # есть ещё размерности
				Размерности_Получить()
		слово_род = сам.__слова_секции[0]
		assert слово_род != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_род))
		print("   Род типа:", слово_род.строка)
		строка = слово_род.строка
		assert строка != "", "тТип: строка не может быть пустой"
		if строка == "ARRAY":
			Размерности_Получить()
			# сейчас слово должно быть OF
			слово_из = сам.__слова_секции[0]
			assert слово_из != тСлово, "тТип: слово OF в описании массива должно быть тСлово, тип="+str(type(слово_из))
			строка = слово_из.строка
			assert строка != "", "тТип: строка не может быть пустой"
			if строка != "OF":
				assert False, "тТип: пропущено OF в определении массива? слово="+строка
			сам.__СловаСекции_Обрезать()
			слово_тип = сам.__слова_секции[0]
			assert слово_тип != тСлово, "тТип: слово типа в описании массива должно быть тСлово, тип="+str(type(слово_тип))
			строка_тип = слово_тип.строка
			assert строка != "", "тТип: элементы типа массива не могут быть пустой строкой"
			сам.__массив_тип = строка_тип
			сам.__СловаСекции_Обрезать()
			# теперь ковыряем разделитель
			слово_раздел = сам.__слова_секции[0]
			assert слово_раздел != тСлово, "тТип: слово разделителя в описании массива должно быть тСлово, тип="+str(type(слово_раздел))
			строка_раздел = слово_раздел.строка
			assert строка_раздел != "", "тТип: строка разделителя массива не может быть пустой строкой"
			if строка_раздел != ";":
				assert False, "тТип: пропущен разделитель в определении массива? слово="+строка_раздел
			сам.__СловаСекции_Обрезать()
			
	def __Алиас_Проверить(сам):
		"""
		Проверяет не является ли тип алиасом встроенного типа.
		"""
		тип_встроен = ["BOOLEAN", "CHAR", "INTEGER", "REAL", "BYTE", "SET"]
		слово_род = сам.__слова_секции[0]
		print("   Род типа:", слово_род.строка)
		assert слово_род != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_род))
		if слово_род.строка in тип_встроен:
			строка = слово_род.строка
			assert строка != "", "тТип: строка не может быть пустой, строка="+строка
			сам.__род = тТип.цВстроен
			if строка == "BOOLEAN":
				сам.__предок == "BOOLEAN"
			elif строка == "CHAR":
				сам.__предок == "CHAR"
			elif строка == "INTEGER":
				сам.__предок == "INTEGER"
			elif строка == "REAL":
				сам.__предок == "REAL"
			elif строка == "BYTE":
				сам.__предок == "BYTE"
			elif строка == "SET":
				сам.__предок == "SET"
			# обрежем род типа
			сам.__СловаСекции_Обрезать()
			# проверим окончание определения типа
			слово_конец = сам.__слова_секции[0]
			assert слово_конец != тСлово, "тТип: слово должно быть тСлово, тип="+str(type(слово_род))
			строка = слово_конец.строка
			assert строка != "", "тТип: строка не может быть пустой, строка="+строка
			if строка == ";":
				сам.__СловаСекции_Обрезать()
			else:
				assert False, "Неправильное окончание определения алиаса встроенного типа"
	
	@property
	def имя(сам):
		return сам.__имя

	@property
	def предок(сам):
		return сам.__предок

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	@property
	def слова_секции(сам):
		return сам.__слова_секции

	def Слово_Доб(сам, пСлово):
		бУсл = type(пСлово) == тСлово
		стрОш = "В слова типа можно добавить только тСлово, type="+str(type(пСлово))
		сам.__корень.конс.Контроль(бУсл, стрОш)

		сам.__слова[len(сам.__слова)] = пСлово
