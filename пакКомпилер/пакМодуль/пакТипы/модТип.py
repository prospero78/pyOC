# coding: utf8
"""
Модуль предоставляет класс для разбора типа.
Простой тип может содержать определения других подтипов и членов.
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль.пакТипы import модРод as мРод
	from . модПоле import тПоле
	from . модТипБазовый import тТипБазовый
	from . модТипАлиас import тТипАлиас
	from . модТипМассив import тТипМассив

class тТип(тТипБазовый):
	def __init__(сам, пКорень, пСловаСекции):
		тТипБазовый.__init__(сам, пКорень, пСловаСекции)

		сам.массив_размерность = {} # заполняется при определении массива
		сам.__запись_поля = {} # словарь полей типа RECORD
		сам.__РодТипа_Проверить()

	def __РодТипа_Проверить(сам):
		"""
		Проверяет род встреченного типа. Возможны варианты:
		1. Алиас встроенного типа.

		2.Массив чего-либо

		3. Пустая запись, должна заканчиваться "END;" (просто запись без членов -- бесполезна,
			но для расширения в шине сообщений -- бывает может пригодиться), скорей всего с
			множеством полей.

		4. Запись с полями, множественные уровни вложенности. Рекурсивный анализ.
			Заканчивается на "END;", но после слова "RECORD" идёт не "END"

		5. ....
		"""
		if сам.род == мРод.сВстроен: # текущий тип основан на встроенном типе
			алиас = тТипАлиас(сам)
		elif сам.род == мРод.сМассив: # текущий тип основан на массиве
			массив = тТипМассив(сам)
		elif сам.род == мРод.сЗапись: # текущий тип основан на записе
			сам.__ЗаписьПусто_Проверить()
		elif сам.род == мРод.сЗаписьСложная: # тип был не пустая запись НЕТ ТАКОГО ТИПА
			# здесь уже должно быть первое имя типа
			# все остальные поля предварительно заполнены
			сам.__Запись_Проверить()
		else:
			assert False, "тТип: неизвестный род записи, род=" + сам.род
		сам.Паспорт_Печать()

	def __Запись_Проверить(сам):
		"""
		Проверяет сложную структуру записи.
		Может иметь множество полей и вложенных записей.
		Запись уже проверена на имя, и слово[0] содержит "("
		"""
		def Предок_Получ():
				слово_предок = сам.слова_секции[0]
				assert слово_предок != тСлово, "тТип: слово-предок должно быть тСлово, тип="+str(type(слово_предок))
				строка_предок = слово_предок.строка
				assert строка_предок != str, "тТип: слово-предок должно быть str, тип="+str(type(строка_предок))
				assert строка_предок != "", "тТип: предок записи не может быть пустым"
				сам.__предок = строка_предок
				сам.СловаСекции_Обрезать()
		def СкобкаЛевая_Обрезать():
			"""
			Скобка слева уже проверена, что она есть в тТип.ЗаписьПусто_Проверить()
			"""
			сам.СловаСекции_Обрезать()
		def СкобкаПрав_Обрезать():
				слово_скобка = сам.слова_секции[0]
				assert слово_скобка != тСлово, "тТип: слово скобка должно быть тСлово, тип="+str(type(слово_скобка))
				строка_скобка = слово_скобка.строка
				assert строка_скобка != str, "тТип: скобка справа предка записи должен быть str, "+str(type(строка_скобка))
				assert строка_скобка != "", "тТип: скобка справа предок записи не может быть пустым"
				if строка_скобка == ")": # закрытие имени предка
					сам.СловаСекции_Обрезать()
				else:
					assert False, "тТип: пропущена закрывающая скобка предка? \""+строка_скобка+"\""
		def ИмяПоля_Проверить():
			"""
			Пытается вычислить все поля в сложной записи.
			"""
			слово_поле = сам.слова_секции[0]
			assert слово_поле != тСлово, "тТип: слово поля должно быть тСлово, тип="+str(type(слово_род))
			if слово_поле.ЕслиИмя():
				строка_поле = слово_поле.строка
				assert строка_поле != "", "тТип: строка поля не может быть пустой"
				сам.СловаСекции_Обрезать()
				return строка_поле
			else:
				assert False, "Имя поля в определении типа должно быть именем, " + слово_поле.строка
		def ТипПоля_Проверить():
			"""
			Пытается вычислить все поля в сложной записи.
			"""
			слово_тип = сам.слова_секции[0]
			assert слово_тип != тСлово, "тТип: слово поля должно быть тСлово, тип="+str(type(слово_тип))
			if слово_тип.ЕслиИмя():
				строка_тип = слово_тип.строка
				assert строка_тип != "", "тТип: строка поля не может быть пустой"
				сам.СловаСекции_Обрезать()
				return строка_тип
			else:
				assert False, "Имя поля в определении типа должно быть именем, " + слово_поле.строка
		СкобкаЛевая_Обрезать()
		Предок_Получ()
		СкобкаПрав_Обрезать()
		if сам.ЗаписьКонец_Обрезать():
			сам.Разделитель_Обрезать()
			print("Это пустая запись с предком")
		else:
			# проверяем поле на имя
			строка_поле = ИмяПоля_Проверить()
			# строка уже проверена на допустимость имени
			поле = {}
			поле["имя"] = строка_поле
			if сам.Двоеточие_Обрезать():
				# это точно поле
				строка_тип = ТипПоля_Проверить()
				поле['тип'] = строка_тип
				сам.__запись_поля[len(сам.__запись_поля)] = поле
				сам.Разделитель_Обрезать()

	def __ЗаписьПусто_Проверить(сам):
		"""
		Тип может быть пустой записью.
		Бывает полезно при расширении исходной записи.
		"""
		def ЕслиЗапись():
			строка = сам.Слово_Проверить()
			if строка == "RECORD":
				сам.СловаСекции_Обрезать()
				бВыход = True
			else:
				бВыход = False
			return бВыход
		if ЕслиЗапись():
			if сам.ЗаписьКонец_Обрезать():
				сам.Разделитель_Обрезать()

				#сам.__род = мРод.сЗаписьПусто
				#сам.__предок = мРод.сБезПредка
			else:
				#сам.__род = мРод.сЗаписьСложная
				pass

	def Слово_Доб(сам, пСлово):
		бУсл = type(пСлово) == тСлово
		стрОш = "В слова типа можно добавить только тСлово, type="+str(type(пСлово))
		сам.__корень.конс.Контроль(бУсл, стрОш)

		сам.__слова[len(сам.__слова)] = пСлово

	def Паспорт_Печать(сам):
		print("      род     =", сам.род)
		print("      предок  =", сам.предок)
		if сам.предок == "ARRAY":
			for ключ in range(len(сам.массив_размерность)):
				print("      ключ ", ключ, ":",сам.массив_размерность[ключ])
			print("      элем    =", сам.массив_тип)
		print()
