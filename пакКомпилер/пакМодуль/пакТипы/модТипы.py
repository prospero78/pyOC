# coding: utf8
"""
Модуль определяет разбор секции типов.
"""

if True:
	from пакКомпилер.пакСлово import тСлово
	from .модТип import тТип
	from пакКомпилер.пакМодуль.пакСекция import тСекция

class тТипы(тСекция):
	def __init__(сам, пДанные):
		тСекция.__init__(сам, пДанные)
		сам.__типы = {} # словарь по словам каждого типа в модуле
		сам.__бТипыНеПустые = False # По умолчанию секция TYPE пустая
		сам.__Обработать()

	def __Слово_TYPE_Обрезать(сам):
		"""
		Первое слово в списке слов должно быть TYPE.
		Если нет -- значит в исходнике нет описания типов.
		Возвращает результат встречи с TYPE
		"""
		слово = сам.слова_модуль[0]
		if слово.строка =='TYPE':
			# укоротить типы
			слова = {}
			for счёт in range(1, len(сам.слова_модуля)):
				слово = сам.слова_модуля[счёт]
				слово._Номер_Уст(счёт-1)
				слова[счёт-1] = слово
			сам.слова_модуля = {}
			сам.слова_модуля = слова
			сам.бСекцияЕсть = True
		return сам.бСекцияЕсть

	def __ЕслиТипыНеПустые(сам):
		"""
		Может быть следующее слово:   ; VAR PROCEDURE BEGIN (* END модуля уже отброшено *)
		Секция TYPE может быть пустой, но если есть типы, они должны заканчиваться на ;
		"""
		def Слово_Проверить():
			бУсл = (type(слово) == тСлово)
			стрОш = "Слово должно быть тСлово, type=" + str(type(слово))
			assert бУсл, стрОш

		слово = сам.слова_модуль[0] # первое слово после TYPE, а сам TYPE уже распознан и отброшен
		Слово_Проверить()

		# проверим на внезапный конец секции
		бМаркер = (слово.строка in ["VAR", "PROCEDURE", "BEGIN"])
		if not бМаркер: # секция типизации не пустая
			сам.__бТипыНеПустые = True
		return сам.__бТипыНеПустые

	def __ЕслиТипыОграничены(сам):
		"""
		Ищет разделитель окончания типов.
		Сканируем слова все подряд.
		Может быть следующее слово-маркер окончания секции типов: VAR PROCEDURE BEGIN,
		так как типов может быть несколько, то ";" не подходит
		Первое слово всегда должен быть именем типа и не может быть маркером
		Произвольное слово может быть ";" и не может быть маркером
		"""
		def Слово_Проверить():
			бУсл = type(слово) == тСлово
			стрОш = "тТипы: Слово должно быть тСлово, type=" + str(type(слово))
			assert бУсл, стрОш
		def Маркер():
			сам.__бМаркер = (слово.строка in ["VAR", "PROCEDURE", "BEGIN"])
		цСловМодульВсего = len(сам.слова_модуль) - 1 # отсчёт начинается с нуля
		цСловоСчёт = 0 # первый слово после TYPE, а сам TYPE уже распознали и отбросили
		слово = сам.слова_модуль[цСловоСчёт]
		Слово_Проверить()
		Маркер()
		while (not сам.__бМаркер) and (цСловоСчёт < цСловМодульВсего ):
			цСловоСчёт += 1
			слово = сам.слова_модуль[цСловоСчёт]

			Слово_Проверить()
			Маркер()
		цСловоСчёт -= 1
		слово = сам.слова_модуль[цСловоСчёт]
		сам.слово_конец = слово
		# Проверка на окончание секции типов
		if слово.строка != ";":
			сам.ошибка.Печать("тТипы: слово ограничение секции типов должно быть ';', слово= " + слово.строка)

	def __Типы_Разделить(сам):
		"""
		Пока не исчерпаны слова секции -- последовательно вызываем новый тип.
		"""
		while len(сам.слова_секции) > 0:
			парам={}
			парам['секция'] = сам
			парам['слова']  = сам.слова_секции
			тип = None
			тип = тТип(парам)
			сам.__типы[len(сам.__типы)] = тип
			сам.слова_секции = None
			сам.слова_секции = тип.слова_секции
		print("После обработки типов:")
		for ключ in сам.слова_секции:
			print(сам.слова_секции[ключ])

	def __Обработать(сам):
		"""
		Проводит разбор секции TYPE.
		"""
		if сам.__Слово_TYPE_Обрезать():
			pass # print("Есть типы!")
		if сам.__ЕслиТипыНеПустые():
			pass # print("Типы не пустые!")
			#сам.Теги_Печать()
			сам.__ЕслиТипыОграничены()
			#сам.Теги_Печать()
			сам.СловаСекции_Получить()
			#сам.СловаСекции_Печать()
			#сам.Конст_Печать()
			сам.__Типы_Разделить()
