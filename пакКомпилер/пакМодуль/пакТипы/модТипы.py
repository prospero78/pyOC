"""
Модуль определяет разбор секции типов.
"""

if True:
   from пакКомпилер.пакТег import тТег

class тТипы:
   def __init__(self, root, теги):
      self.__root = root
      assert type(теги) == dict, "В секцию типов должен передаваться словарь тегов, type="+type(теги)
      self.__теги = теги # все теги исходника
      self.__типытеги = {} #  Все теги секции TYPE
      self.__типы = {} # хитрый словарь по каждому типу
      self.__бТипы = False # Признак наличия типов
      self.ошибка = root.ошибка

   @property
   def импорт(self):
      return self.__импорт

   def ЕслиТипы(self):
      """
      Первый тег в списке тегов должен быть TYPE.
      Если нет -- значит в исходнике нет описания типов.
      """
      тег = self.__теги[0]
      if тег.имя =='TYPE':
         # укоротить типы
         теги = {}
         for счёт in range(1, len(self.__теги)):
            тег = self.__теги[счёт]
            тег._Номер_Уст(счёт-1)
            теги[счёт-1] = тег
         self.__теги = {}
         self.__теги = теги
         бВыход = True
      else:
         бВыход = False
      self.__бТипы = бВыход
      return бВыход

   def ЕслиТипыПусто(self):
      """
      Может быть следующий тег:   ; VAR PROCEDURE BEGIN (* END модуля уже отброшено *)
      Секция TYPE может быть пустой, но если есть типы, они должны заканчиваться на ;
      """
      тег = self.__теги[0] # первый тег после TYPE, а сам TYPE уже распознан и отброшен
      assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
      # проверим на внезапный конец секции
      маркер = (тег.имя == "VAR") or (тег.имя == "PROCEDURE") or (тег.имя == "BEGIN")
      бПусто = True
      if маркер: # секция типизации пустая
         self.__бТипы = False
      else:
         бПусто = False
      return бПусто

   def ЕслиТипыОграничено(self):
      """
      Ищет разделитель окончания типов.
      Сканируем теги все подряд.
      Может быть следующий тег-маркер окончаня: VAR PROCEDURE BEGIN
      Первый тег всегда должен быть именем типа и не может быть маркером
      Произвольный тег может быть ";" и не может быть маркером
      """
      тег_всего = len(self.__теги)
      тег_счёт = 0 # первый тег после TYPE, а сам TYPE уже распознали и отбросили
      тег = self.__теги[тег_счёт]
      маркер = (тег.имя == "VAR") or \
               (тег.имя == "PROCEDURE") or \
               (тег.имя == "BEGIN")
      while (not маркер) and (тег_счёт < тег_всего):
         тег_счёт += 1
         тег = self.__теги[тег_счёт]
         assert type(тег) == тТег, "Тег должен быть тТег, type="+type(тег)
         маркер = (тег.имя == "VAR") or \
               (тег.имя == "PROCEDURE") or \
               (тег.имя == "BEGIN")
      тег_счёт -= 1
      тег = self.__теги[тег_счёт]
      self.__тег_конец = тег
      # Проверка на окончание секции типов
      if тег.имя !=";":
         self.ошибка.Печать("Тег должен быть ';', тег="+тег.имя)

   def Теги_Получить(self):
      """
      Выбирает теги по секции типов.
      Дальше работает только с ними.
      """
      теги = {}  # будущий словарь тегов
      for счёт_типы in range(0, self.__тег_конец.номер+1): # TYPE уже отброшено
         тег = self.__теги[счёт_типы]
         тег._Номер_Уст(счёт_типы)
         #print("т+", счёт_типы, "num",тег.номер, тег.имя)
         теги[счёт_типы] = тег
      self.__типытеги = теги

      теги = {}  # будущий словарь тегов
      счёт = 0
      for счёт_типы in range(self.__тег_конец.номер+1, len(self.__теги)):
         тег = self.__теги[счёт_типы]
         тег._Номер_Уст(счёт)
         #print("т-", счёт_типы, тег.номер, тег.имя)
         теги[счёт] = тег
         счёт += 1
      self.__теги = {}
      self.__теги = теги

   def Типы_Разбить(self):
      """
      У нас уже есть словарь типов. Теперь их надо разбить на части.
      Тег 1 -- имя
      Тег 2 -- =
      Тег 3 -- варианты: POINTER, RECORD, ARRAY
      Дальше варианты по порядку следования тегов
      """
      #print("keys=", self.__консттеги.keys())
      #for i in self.__консттеги:
      #   print(i, self.__консттеги[i])
      счёт_типы = 0 # Счётчик типов
      счёт = 0
      while счёт < len(self.__типытеги)-1:
         #print(счёт, len(self.__консттеги))
         тег = self.__типытеги[счёт] # Должно быть имя типа
         if (not тег.ЕслиИмя()):
            #print(тег.имя, " номер", тег.номер)
            self.ошибка.Коорд("Неправильное имя типа", тег.коорд, тег.стр)
         else:
            тип = {}
            тип["tag"] = тег
            тип["exp"] = {}
            счёт += 1
            тег = self.__типытеги[счёт] # Должно быть "=" или "*"
            # проверим на экспорт
            if тег.имя == "*":
               тип["export"] = "True"
               счёт += 1
               тег = self.__типытеги[счёт] # Должно быть "="
            elif тег.имя == "=":
               тип["export"] = "False"
            else:
               self.ошибка.Коорд("Ошибка в определении типа", тег.коорд, тег.стр)
            #
            # проверим на присвоение
            #
            if тег.имя != "=":
               стр = self.__root.исх.строки(тег.коорд.стр)
               self.ошибка.Коорд("Неправильное присвоение имени типа", тег.коорд, стр)
            else: # всё правильно, вычисляем какое ключевое слово тут
               счёт += 1
               тег = self.__типытеги[счёт] # Должно быть что-то
               счёт_выраж = 0
               if тег.имя == "POINTER":
                  тег["type"] = "POINTER"
                  счёт += 1
                  тег = self.__типытеги[счёт] # Должно быть "TO"
                  if тег.имя != "TO":
                     self.ошибка.Коорд("Неправильная форма присвоение PONTER", тег.коорд, тег.стр)
                  счёт += 1
                  тег = self.__типытеги[счёт] # Должно быть "ARRAY", "RECORD", "PROCEDURE"
                  if тег.имя == "ARRAY":
                     # После ARRAY должно идти число или имя константы-числа
                     if тег.ЕслиЧисло() or тег.ЕслиИмя():
                        # Должно идти запятая или "OF"
                        pass

               while тег.имя != ";" and счёт < len(self.__типытеги)-1:
                  тип["exp"][счёт_выраж] = тег
                  счёт_выраж += 1
                  счёт += 1
                  тег = self.__типытеги[счёт] # Должно быть новое имя
               self.__типы[счёт_типы] = тип
               счёт_типы += 1
               счёт += 1
      if тег.имя != ";":
         assert тег.имя == ";", "Неправильно закончился разбор типов, тег(;)="+тег.имя


   def Теги_Печать(self):
      print("\nтТипы.Теги_Печать()")
      for keys in self.__теги:
         тег = self.__теги[keys]
         print(тег)

   def Конст_Печать(self):
      print("\nтТипы.Типы_Печать()")
      for keys in self.__типытеги:
         тег = self.__типытеги[keys]
         print(keys, тег)

   def Обработать(self):
      """
      Проводит разбор секции TYPE.
      """
      if self.ЕслиТипы():
         print("Есть типы!")
         if not self.ЕслиТипыПусто():
            print("Типы не пустые!")
            #self.Теги_Печать()
            self.ЕслиТипыОграничено()
            #self.Теги_Печать()
            self.Теги_Получить()
            #self.Теги_Печать()
            #self.Конст_Печать()
            self.Типы_Разбить()
      else:
         print("Нет типов!")
