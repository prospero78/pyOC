# coding: utf8
"""
Модуль предоставляет тип Исходника.
Производит первоначальное чтение, разбивает на типовые цепочки литер,
отбрасывает мусор
"""

if True:
	from .модКоординаты import тКоорд
	from .модКоордИсх import тКоордИсх
	from .модИсхСтроки import тИсхСтроки
	from .модИсхТекст import тИсхТекст
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль import тМодуль

class тИсходник:
	def __init__(сам, пКорень, пИмяФайла):
		def ИмяФайла_Проверить():
			"""
			1. Имя файла должно быть строкой
			2. Имя файла не может быть пустым
			"""
			############## 1 ##########
			бУсл = type(пИмяФайла) == str
			стрСообщ = "тИсходник.__init__(): пИмяФайла должно быть строкой, type(пИмяФайла)=" + \
						str(type(пИмяФайла))
			сам.конс.Проверить(бУсл, стрСообщ)
			
			############ 2 ############
			бУсл = пИмяФайла != ""
			стрСообщ = "тИсходник.__init__(): пИмяФайла не должно быть пустым"
			сам.конс.Проверить(бУсл, стрСообщ)
		
		сам.__корень = пКорень
		сам.конс = пКорень.конс 
		
		ИмяФайла_Проверить()
		
		сам.__исх  = тИсхТекст(пКорень, пИмяФайла)   # хранит текст исходного кода
		сам.строки = тИсхСтроки(пКорень, сам.__исх())# список строк исходного текста
		сам.__слова = {}      # список слов в тексте
		сам.__цСловаВсего = 0 # общее количество слов в тексте
		сам.коорд = тКоордИсх(1, 0) # общая позиция в исходном тексте
		сам.указ = 0          # бегунок в исходнике
		сам.модули    = {}    # перечень модулей для компиляции
		сам.ошибка    = пКорень.ошибка

	def Слово_Добав(сам, пСлово, пРод):
		"""
		Процедура добавляет слово с атрибутами положения в исходном тексте.
		Строки исходника остаются отдельно.
		"""
		коорд = тКоорд(сам.__корень, сам.коорд.стр, сам.коорд.поз)
		слово = тСлово(сам.__корень, коорд, пСлово, сам.__цСловаВсего, пРод)
		сам.__слова[сам.__цСловаВсего] = слово
		сам.__цСловаВсего += 1
		сам.коорд.Поз_Доб()

	def НаТеги(сам):
		def Пробел(лит):
			if лит in [' ', '\t']:
				сам.коорд.Поз_Доб()
		def Запятая(лит):
			if лит ==',':
				сам.Слово_Добав(',', тСлово.кЗапятая)
		def ТочкаЗапятая(лит):
			if лит == ';':
				сам.Слово_Добав(';', тСлово.кТочкаЗапятая)
		def Плюс(лит):
			if лит == '+':
				сам.Слово_Добав('+', тСлово.кПлюс)
		def Минус(лит):
			if лит == '-':
				сам.Слово_Добав('-', тСлово.кМинус)
		def Деление(лит):
			if лит == '/':
				сам.Слово_Добав('/', тСлово.кДеление)
		def ЛеваяСкобка(лит):
			if лит == '(':
				if лит + сам.__исх.Лит(сам.указ+1) != "(*":
					сам.Слово_Добав('(', тСлово.кСкобкаОткрКругл)
				else:
					сам.Слово_Добав('(*', тСлово.кКомментНачать)
					сам.коорд.Поз_Доб()
					сам.указ += 1
		def ПраваяСкобка(лит):
			if лит == ')':
				сам.Слово_Добав(')', тСлово.кСкобкаЗакрКругл)
		def НоваяСтрока(лит):
			if лит == '\n':
				сам.коорд.Стр_Доб()
				сам.коорд.Поз_Сброс()
		def Умножить(лит):
			if лит == '*':
				if лит + сам.__исх.Лит(сам.указ+1) == "*)":
					сам.Слово_Добав('*)', тСлово.кКомментЗакончить)
					сам.коорд.Поз_Доб()
					сам.указ += 1
				else:
					сам.Слово_Добав('*', тСлово.кУмножить)
		def Двоеточие(лит):
			if лит == ':':
				if лит + сам.__исх.Лит(сам.указ+1) == ":=":
					сам.Слово_Добав(':=', тСлово.кПрисвоить)
					сам.коорд.Поз_Доб()
					сам.указ += 1
				else:
					сам.Слово_Добав(':', тСлово.кОпределить)
		def ПереводКаретки(лит):
			if лит == '\r':
				сам.коорд.поз += 1
		def ЕслиСущность(лит):
			"""
			Если началось число или имя сущности.
			"""
			# если "_" или буква -- то это только имя
			сущн = ""
			if лит=="_" or лит.isalpha():
				while лит.isalpha() or лит.isdigit() or лит=="_":
					сущн += лит
					сам.указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.указ)
				else:
					# откат на одну позицию
					сам.указ -= 1
					сам.коорд.поз = сам.коорд.поз - len(сущн)
					сам.Слово_Добав(сущн, тСлово.кИмя)
					сам.коорд.поз = сам.коорд.поз + len(сущн)-1

			# возможно это число
			elif лит.isdigit():
				while лит.isdigit() or лит == ".":
					сущн += лит
					сам.указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.указ)
				else:
					# откат на одну позицию
					сам.указ -= 1
					сам.коорд.поз = сам.коорд.поз - len(сущн)
					сам.Слово_Добав(сущн, тСлово.кЧисло)
					сам.коорд.поз = сам.коорд.поз + len(сущн)-1
		def Равно(лит):
			if лит =='=':
				сам.Слово_Добав('=', тСлово.кСравнитьРавно)
		def Точка(лит):
			if лит =='.':
				сам.Слово_Добав('.', тСлово.кТочка)
		def Кавычка2(лит):
			"""
			Вычисляет строки.
			"""
			if лит == '"':
				стр = ''
				лит = ""
				while лит !='"':
					сам.указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.указ)
					стр += лит
				сам.Слово_Добав(стр, тСлово.кСтрока)
				сам.коорд.Поз_Доб()

		исх_длина = сам.__исх.длина - 1
		while сам.указ-1 < исх_длина:
			лит = сам.__исх.Лит(сам.указ)
			Пробел(лит)
			Запятая(лит)
			ТочкаЗапятая(лит)
			ЛеваяСкобка(лит)
			ПраваяСкобка(лит)
			НоваяСтрока(лит)
			Умножить(лит)
			Двоеточие(лит)
			ПереводКаретки(лит)
			ЕслиСущность(лит)
			Равно(лит)
			Точка(лит)
			Кавычка2(лит)
			Плюс(лит)
			Минус(лит)
			Деление(лит)
			сам.указ += 1

	def Слова_Печать(сам):
		for ключ in сам.__слова:
			слово = сам.__слова[ключ]
			сам.конс.Печать(str(слово))

	def Комментарии_Выкинуть(сам):
		"""
		Выкидывать по кругу комментарии, пока не будут выкинуты полностью.
		"""
		def Коммент_Выкинуть():
			"""
			Нагло выкидывает комментарий из слов.
			Должен контролировать непарное открытие и закрытие комментариев.
			"""
			бКоммент = False
			лцСловоНомер = 0
			лцНомерЧистый = 0
			слова = {} # чистый список слов
			лцУровень = 0 # уровен вложенных комментариев
			while лцСловоНомер < len(сам.__слова):
				слово = сам.__слова[лцСловоНомер]
				if слово.строка == "(*": # начался пропуск слов
					бКоммент = True
					лцУровень += 1
				elif слово.строка == "*)":
					лцУровень -= 1
				
				# пропуск слов внутри комментария
				if лцУровень == 0 and слово.строка != "*)":
					слово._Номер_Уст(лцНомерЧистый)
					слова[лцНомерЧистый] = слово
					лцНомерЧистый += 1

				лцСловоНомер += 1
			# проверка на сбалансированность уровня вложения
			бУсл = лцУровень == 0
			стрОш = "Открытие и закрытие комментариев в модуле не сбалансировано, лцУровень=" + str(лцУровень)
			сам.конс.Проверить(бУсл, стрОш) 
			сам.__слова = слова
			return бКоммент
		while Коммент_Выкинуть():
			pass

	def Модуль_Обработать(сам):
		модуль = тМодуль(сам.__корень, сам.__слова)
		сам.модули[0] = модуль
		модуль.Обработать()

	def Обработать(сам):
		#сам.строки.ПоСтр_Печать()
		сам.НаТеги()
		#print('===Грязные слова===')
		#сам.Слова_Печать()
		сам.Комментарии_Выкинуть()
		#сам.конс.Печать("===Чистые слова===")
		#сам.Слова_Печать()
		сам.Модуль_Обработать()
