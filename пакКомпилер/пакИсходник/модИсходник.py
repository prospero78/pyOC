"""
Модуль предоставляет тип Исходника.
Производит первоначальное чтение, разбивает на типовые цепочки литер,
отбрасывает мусор
"""

if True:
	from .модКоординаты import тКоорд
	from .модКоордИсх import тКоордИсх
	from .модИсхСтроки import тИсхСтроки
	from .модИсхТекст import тИсхТекст
	from пакКомпилер.пакСлово import тСлово
	from пакКомпилер.пакМодуль import тМодуль

class тИсходник:
	def __init__(сам, корень, имя_файла):
		def ИмяФайла_Проверить():
			"""
			1. Имя файла должно быть строкой
			2. Имя файла не может быть пустым
			"""
			############## 1 ##########
			бУсл = type(имя_файла) == str
			стрСообщ = "тИсходник.__init__(): имя_файла должно быть строкой, type(имя_файла)=" + \
						str(type(имя_файла))
			сам.конс.Проверить(бУсл, стрСообщ)
			
			############ 2 ############
			бУсл = имя_файла != ""
			стрСообщ = "тИсходник.__init__(): имя_файла не должно быть пустым"
			сам.конс.Проверить(бУсл, стрСообщ)
		
		сам.__корень = корень
		сам.конс = корень.конс 
		
		ИмяФайла_Проверить()
		
		сам.__исх  = тИсхТекст(корень, имя_файла)   # хранит текст исходного кода
		сам.строки = тИсхСтроки(корень, сам.__исх())# список строк исходного текста
		сам.__слова = {}      # список слов в тексте
		сам.__слова_всего = 0 # общее количество слов в тексте
		сам.коорд = тКоордИсх(1, 0) # общая позиция в исходном тексте
		сам.указ = 0          # бегунок в исходнике
		сам.модули    = {}    # перечень модулей для компиляции
		сам.ошибка    = корень.ошибка

	def Слово_Добав(сам, имя):
		"""
		Процедура добавляет слово с атрибутами положения в исходном тексте.
		Строки исходника остаются отдельно.
		"""
		коорд = тКоорд(сам.__корень, сам.коорд.стр, сам.коорд.поз)
		слово = тСлово(сам.__корень, коорд, имя, сам.__слова_всего)
		сам.__слова[сам.__слова_всего] = слово
		сам.__слова_всего += 1
		сам.коорд.Поз_Доб()

	def НаТеги(сам):
		def Пробел(лит):
			if лит in [' ', '\t']:
				сам.коорд.Поз_Доб()
		def Запятая(лит):
			if лит ==',':
				сам.Слово_Добав(',')
		def ТочкаЗапятая(лит):
			if лит == ';':
				сам.Слово_Добав(';')
		def Плюс(лит):
			if лит == '+':
				сам.Слово_Добав('+')
		def Минус(лит):
			if лит == '-':
				сам.Слово_Добав('-')
		def Деление(лит):
			if лит == '/':
				сам.Слово_Добав('/')
		def ЛеваяСкобка(лит):
			if лит == '(':
				if лит + сам.__исх.Лит(сам.указ+1) != "(*":
					сам.Слово_Добав('(')
				else:
					сам.Слово_Добав('(*')
					сам.коорд.Поз_Доб()
					сам.указ += 1
		def ПраваяСкобка(лит):
			if лит == ')':
				сам.Слово_Добав(')')
		def НоваяСтрока(лит):
			if лит == '\n':
				сам.коорд.Стр_Доб()
				сам.коорд.Поз_Сброс()
		def Умножить(лит):
			if лит == '*':
				if лит + сам.__исх.Лит(сам.указ+1) != "*)":
					сам.Слово_Добав('*')
				else:
					сам.Слово_Добав('*)')
					сам.коорд.Поз_Доб()
					сам.указ += 1
		def Двоеточие(лит):
			if лит == ':':
				if лит + сам.__исх.Лит(сам.указ+1) != ":=":
					сам.Слово_Добав(':')
				else:
					сам.Слово_Добав(':=')
					сам.коорд.Поз_Доб()
					сам.указ += 1
		def ПереводКаретки(лит):
			if лит == '\r':
				сам.коорд.поз += 1
		def ЕслиСущность(лит):
			"""
			Если началось число или имя сущности.
			"""
			# если "_" или буква -- то это только имя
			сущн = ""
			if лит=="_" or лит.isalpha():
				while лит.isalpha() or лит.isdigit() or лит=="_":
					сущн += лит
					сам.указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.указ)
				else:
					# откат на одну позицию
					сам.указ -= 1
					сам.коорд.поз = сам.коорд.поз - len(сущн)
					сам.Слово_Добав(сущн)
					сам.коорд.поз = сам.коорд.поз + len(сущн)-1

			# возможно это число
			elif лит.isdigit():
				while лит.isdigit() or лит == ".":
					сущн += лит
					сам.указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.указ)
				else:
					# откат на одну позицию
					сам.указ -= 1
					сам.коорд.поз = сам.коорд.поз - len(сущн)
					сам.Слово_Добав(сущн)
					сам.коорд.поз = сам.коорд.поз + len(сущн)-1
		def Равно(лит):
			if лит =='=':
				сам.Слово_Добав('=')
		def Точка(лит):
			if лит =='.':
				сам.Слово_Добав('.')
		def Кавычка2(лит):
			"""
			Вычисляет константные строки.
			"""
			if лит == '"':
				стр = '"'
				лит = ""
				while лит !='"':
					сам.указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.указ)
					стр += лит
				сам.Слово_Добав(стр)
				сам.коорд.Поз_Доб()

		исх_длина = сам.__исх.длина - 1
		while сам.указ-1 < исх_длина:
			лит = сам.__исх.Лит(сам.указ)
			Пробел(лит)
			Запятая(лит)
			ТочкаЗапятая(лит)
			ЛеваяСкобка(лит)
			ПраваяСкобка(лит)
			НоваяСтрока(лит)
			Умножить(лит)
			Двоеточие(лит)
			ПереводКаретки(лит)
			ЕслиСущность(лит)
			Равно(лит)
			Точка(лит)
			Кавычка2(лит)
			Плюс(лит)
			Минус(лит)
			Деление(лит)
			сам.указ += 1

	def Теги_Печать(сам):
		for keys in сам.__слова:
			тег = сам.__слова[keys]
			сам.конс.Печать(str(тег))

	def Комментарии_Выкинуть(сам):
		"""
		Выкидывать по кругу комментарии, пока не будут выкинуты полностью.
		"""
		def Коммент_Выкинуть():
			"""
			Нагло выкидывает комментарий из тегов.
			Должен контролировать непарное открытие и закрытие комментариев.
			"""
			коммент_есть = False
			номер_тега = 0
			номер_чистого_тега = 0
			слова = {} # чистый список слов
			уровень = 0 # уровен вложенных комментариев
			while номер_тега < len(сам.__слова):
				слово = сам.__слова[номер_тега]
				if слово.строка == "(*": # начался пропуск слов
					уровень += 1
					коммент_есть = True
				elif слово.строка == "*)":
					уровень -= 1

				if уровень == 0 and слово.строка != "*)":
					слово._Номер_Уст(номер_чистого_тега)
					слова[номер_чистого_тега] = слово
					номер_чистого_тега += 1

				номер_тега += 1
			# проверка на сбалансированность уровня вложения
			усл = уровень == 0
			_текст = "Открытие и закрытие комментариев в модуле не сбалансировано, уровень="+str(уровень)
			сам.конс.Проверить(усл, _текст) 
			сам.__слова = слова
			return коммент_есть
		while Коммент_Выкинуть():
			pass

	def Модуль_Обработать(сам):
		модуль = тМодуль(сам.__корень, сам.__слова)
		сам.модули[0] = модуль
		модуль.Обработать()

	def Обработать(сам):
		#сам.строки.ПоСтр_Печать()
		сам.НаТеги()
		#print('===Грязные слова===')
		#сам.Теги_Печать()
		сам.Комментарии_Выкинуть()
		#сам.конс.Печать("===Чистые слова===")
		#сам.Теги_Печать()
		сам.Модуль_Обработать()
