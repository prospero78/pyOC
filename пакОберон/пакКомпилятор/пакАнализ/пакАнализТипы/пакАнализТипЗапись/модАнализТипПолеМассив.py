# coding: utf8
"""
В секции TYPE анализирует поле ARRAY в записи
"""
if True:
	from пакОберон.пакКомпилятор.пакСущность.пакРод import тРод

class тАнализТипПолеМассив:
	def __init__(сам, пДанные):
		def Слова_Проверить():
			бУсл = type(пДанные['слова']) == dict
			стрОш = "тАнализЗаписьПоле: В секцию  должен передаваться словарь слов, type=" + str(type(пДанные['слова']))
			assert бУсл, стрОш
			if пДанные['секция'] != "FIELD_ARRAY":
				assert False, "тАнализЗаписьПоле: ошибочное использование типа в секции FIELD_ARRAY, секция=" + пДанные['секция']
			сам.слова_секции = пДанные['слова']
		Слова_Проверить()
		сам.род = "ARRAY"
		сам.элем = тРод.сБезТипа # элементы массива
		# определяет число размерностей массива и их содержание
		сам.массив_размерность = {}
		сам.__предок = тРод.сБезПредка

		сам.__МАССИВ_Обрезать()
		сам.__Массив_Проверить()
		сам.__ИЗ_Обрезать()
		сам.__Предок_Проверить()
		сам.__Разделитель_Обрезать()

	def __МАССИВ_Обрезать(сам):
		слово_массив = сам.слова_секции[0]
		строка = слово_массив.Проверить()
		if строка != "ARRAY":
			assert False, "тАнализЗаписьПолеМассив: пропущено ARRAY?"+слово_массив.стрИсх
		сам.СловаСекции_Обрезать()

	def __Массив_Проверить(сам):
		"""
		Пытается проверить, является ли поле массивом.
		"""
		def Размерности_Получить():
			"""
			Рекурсивно получает и заполняет размерности массива.
			"""
			# получаем первую размерность массива
			слово_размер = сам.слова_секции[0]
			размер = int(слово_размер.Проверить())
			сам.массив_размерность[len(сам.массив_размерность)] = размер
			сам.СловаСекции_Обрезать()
			# есть ли ещё размерности
			слово_запятая = сам.слова_секции[0]
			запятая = слово_запятая.Проверить()
			if запятая == ",": # есть ещё размерности
				сам.СловаСекции_Обрезать()
				Размерности_Получить()
		Размерности_Получить()

	def __ИЗ_Обрезать(сам):
		"""
		Образает OF (ARRRAY ... OF ... ;)
		"""
		слово_из = сам.слова_секции[0]
		строка = слово_из.Проверить()
		if строка != "OF":
			assert False, "тАнализЗаписьПолеМассив: пропущено OF в определении массива?" + слово_из.стрИсх
		сам.СловаСекции_Обрезать()

	def __Предок_Проверить(сам):
		"""
		Проверяет элемент массива. Должно быть разрешённой строкой и
		не должно быть END.
		Кроме того, имя может быть составным
		===== Улучшенная проверенная версия =======
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		стрОш = "тАнализЗаписьПолеМассив: элемент массива должно быть допустимым именем"
		assert слово_имя.ЕслиСтр_Допустимо(), стрОш + слово_имя.строка + слово_имя.стрИсх
		if сам.__предок != тРод.сБезПредка:
			assert False, "тАнализЗаписьПолеМассив: элемент массива уже назначен  " + сам.элем + слово_имя.стрИсх
		сам.__предок = ""
		while (имя == ".") or (слово_имя.ЕслиСтр_Допустимо()):
			сам.СловаСекции_Обрезать()
			сам.__предок += имя
			слово_имя = сам.слова_секции[0]
			имя = слово_имя.Проверить()
			 # Такое может быть в определении 1) массива 2) предка записи
			if имя == ";" or имя ==")":
				break
			if not (слово_имя.ЕслиСтр_Допустимо() or имя=="."):
				assert False, стрОш + слово_имя.строка + слово_имя.стрИсх

	def __Разделитель_Обрезать(сам):
		"""
		В поле-массиве последнее слово ";" или "END" (* окончание записи *)
		Поэтому его необходимо обрезать
		"""
		слово_раздел = сам.слова_секции[0]
		раздел = слово_раздел.Проверить()
		if раздел == ";":
			сам.СловаСекции_Обрезать()
		elif слово_раздел.строка == "END":
			pass # скобку обрабатывает уровень выше
		else:
			# В типе всегда есть разделитель в конце
			assert False, "тАнализЗаписьПолеМассив: неправильный разделитель поля" + слово_раздел.стрИсх
		print("тАнализЗаписьПолеМассив: 5167 разделитель=", раздел, слово_раздел.стрИсх)

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список
