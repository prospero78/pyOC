# coding: utf8
"""
Модуль для общего типа поля.
Тип поля может быть:
1. Переменные
2. Поля в типах
3. Поля в процедурах.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакРод import тРод

class тАнализЗаписьПоле:
	def __init__(сам, пДанные):
		def Слова_Проверить():
			бУсл = type(пДанные['слова']) == dict
			стрОш = "тАнализЗаписьПоле: В секцию  должен передаваться словарь слов, type=" + str(type(пДанные['слова']))
			assert бУсл, стрОш
			if пДанные['секция'] != "TYPE":
				assert False, "тАнализЗаписьПоле: ошибочное использование типа в секции TYPE, секция=" + пДанные['секция']
		Слова_Проверить()
		сам.слова_секции = пДанные['слова']
		сам.__имя = "" # имя записи
		сам.__бЭкспорт = False # экспорт в полях низкого уровня не вычисляется
		сам.__бЭкспорт_бПрисвоено = False # Защёлка присвоения экспорта
		сам.__бЭкспорт = False # бЭкспорт будет выясняться самими силами поля
		сам.__бСсылка_бПрисвоено = False # Защёлка присвоения ссылки
		сам.__бСсылка = False
		сам.__предок = тРод.сБезПредка

		сам.__ИмяПоле_Проверить()
		сам.__Экспорт_Проверить()
		while сам.__Запятая_Проверить():
			сам.__Имя_Проверить()
			сам.__Экспорт_Проверить()
		сам.__Двоеточие_Проверить()
		сам__Предок_Проверить()
		сам.__Разделитель_Проверить()

	def __ИмяПоле_Проверить(сам):
		"""
		Проверяет имя поля в записи, должно быть простым.
		Поскольку имён полей с оним типом может быть несколько -- каждое
		поле в группе добавляется под своим номером.
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			номер = len(сам.параметры)
			сам.параметры[номер] = имя
			сам.СловаСекции_Обрезать()

	def __Имя_Проверить(сам):
		"""
		Проверяет имя записи. Должно быть простым именем и
		не должно быть "," или ":".
		Имя НЕ МОЖЕТ быть составным
		"""
		бРезульт = False
		слово_имя = сам.слова_секции[0]
		print("тАнализЗаписьПоле: 8335 имя поля=", слово_имя.строка)
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			сам.СловаСекции_Обрезать()
			сам.__имя = имя
			бРезульт = True
		else:
			assert False, "тАнализЗаписьПоле: имя поля должно быть допустимым именем" + слово_имя.стрИсх

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является ли поле экспортируемым.
		"""
		слово_экспорт = сам.слова_секции[0]
		строка_экспорт = слово_экспорт.Проверить()
		if строка_экспорт == "*": # есть экспорт
			сам.СловаСекции_Обрезать()
			сам.__бЭкспорт = True
		elif строка_экспорт == "," or строка_экспорт == ":":
			pass # это определение списка полей
		else:
			assert False, "тАнализЗаписьПоле: Символ экспорта допустим '*' или '='" + слово_экспорт.стрИсх
		print("тАнализЗаписьПоле: 6695 экспорт поля=", сам.__бЭкспорт)

	def __бЭксорт_Уст(сам, пЭкспорт):
		"""
		Устанавливает экспорт с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пЭкспорт) == BOOLEAN, "тАнализЗаписьПоле: пЭкспорт должен быть BOOLEAN, type=" + str(type(пЭкспорт))
		assert сам.__бЭкспорт_бПрисвоено == False, "тАнализЗаписьПоле: пЭкспорт уже присвоен, экспорт=" + сам.__бЭкспорт
		сам.__бЭкспорт_бПрисвоено = True
		сам.__бЭкспорт = пЭкспорт

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	def Предок_Проверить(сам):
		"""
		Проверяет предка поля. Должно быть разрешённой строкой.
		конечный символ ";" или ")"
		Кроме того, имя может быть составным
		===== Улучшенная проверенная версия =======
		"""
		слово_предок = сам.слова_секции[0]
		предок = слово_предок.Проверить()
		стрОш = "тАнализЗаписьПоле: имя поля должно быть допустимым именем"
		assert слово_предок.ЕслиСтр_Допустимо(), стрОш + слово_предок.стрИмя + слово_предок.стрИсх
		assert сам.предок != тРод.сБезТипа, "тАнализЗаписьПоле: предок уже назначен  " + сам.предок + слово_предок.стрИсх
		print("тАнализЗаписьПоле: предок=", слово_предок.стрИсх)
		сам.__предок = ""
		усл1 = (предок == ".") or (слово_предок.ЕслиСтр_Допустимо())
		усл2 = not (предок == ";") or (предок==")")
		while True:
			if (not усл1) and усл2:
				break
			сам.СловаСекции_Обрезать()
			сам.__предок += предок
			слово_предок = сам.слова_секции[0]
			предок = слово_предок.Проверить()
			усл1 = (предок == ".") or (слово_предок.ЕслиСтр_Допустимо())
			усл2 = not (предок == ";") or (предок==")")

		#if not (слово_предок.ЕслиСтр_Допустимо() or предок=="."):
		#	assert False, стрОш + слово_предок.строка + слово_предок.стрИсх

	def Разделитель_Обрезать(сам):
		"""
		В полях последнее слово ";" или ")"
		Поэтому его необходимо обрезать
		"""
		слово_раздел = сам.слова_секции[0]
		if слово_раздел.род == тСлово.кТочкаЗапятая:
			сам.СловаСекции_Обрезать()
		elif слово_раздел.строка == ")":
			pass # скобку обрабатывает уровень выше
		else:
			# В типе всегда есть разделитель в конце
			assert False, "тАнализЗаписьПоле: неправильный разделитель типа" + слово_раздел.стрИсх

	def Имя_Уст(сам, пИмя):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пИмя) == str, "тАнализЗаписьПоле: пИмя должен быть str, type=" + str(type(пИмя))
		assert пИмя != "", "тАнализЗаписьПоле: пИмя не может быть пустым"
		assert сам.__имя == "", "тАнализЗаписьПоле: имя уже присвоено, имя=" + сам.__имя
		сам.__имя = пИмя

	@property
	def имя(сам):
		return сам.__имя

	def бЭксорт_Уст(сам, пЭкспорт):
		"""
		Устанавливает экспорт с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пЭкспорт) == BOOLEAN, "тАнализЗаписьПоле: пЭкспорт должен быть BOOLEAN, type=" + str(type(пЭкспорт))
		assert сам.__бЭкспорт_бПрисвоено == False, "тАнализЗаписьПоле: пЭкспорт уже присвоен, экспорт=" + сам.__бЭкспорт
		сам.__бЭкспорт_бПрисвоено = True
		сам.__бЭкспорт = пЭкспорт

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	def бСсылка_Уст(сам, пСсылка):
		"""
		Устанавливает ссылку с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пСсылка) == bool, "тАнализЗаписьПоле: пСсылка должен быть BOOLEAN, type=" + str(type(пСсылка))
		assert сам.__бСсылка_бПрисвоено == False, "тАнализЗаписьПоле: пСсылка уже присвоен, экспорт=" + сам.__бСсылка
		сам.__бСсылка_бПрисвоено = True
		сам.__бСсылка = пСсылка

	@property
	def бСсылка(сам):
		return сам.__бСсылка

	def Предок_Уст(сам, пПредок):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		# TODO: имя предка может быть составным
		assert type(пПредок) == str, "тАнализЗаписьПоле: пПредок должен быть str, type=" + str(type(пПредок))
		assert пПредок != "", "тАнализЗаписьПоле: пПредок не может быть пустым"
		assert сам.__предок == тРод.сБезПредка, "тАнализЗаписьПоле: имя уже присвоено, имя=" + сам.__предок
		сам.__предок = пПредок

	@property
	def предок(сам):
		return сам.__предок

	@property
	def имя(сам):
		return сам.__имя
