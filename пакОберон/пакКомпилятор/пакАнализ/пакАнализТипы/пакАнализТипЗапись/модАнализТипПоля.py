# coding: utf8
"""
Модуль для типа поле.
Вычисляет все возможные типы полей.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from пакОберон.пакКомпилятор.пакСущность.пакРод import тРод
	from .модАнализТипПолеМассив import тАнализТипПолеМассив

class тАнализТипПоля:
	def __init__(сам, пДанные):
		def Слова_Проверить():
			бУсл = type(пДанные['слова']) == dict
			стрОш = "тАнализЗаписьПоле: В секцию  должен передаваться словарь слов, type=" + str(type(пДанные['слова']))
			assert бУсл, стрОш
			if пДанные['секция'] != "TYPE_FIELD_RECORD":
				assert False, "тАнализЗаписьПоле: ошибочное использование типа в секции TYPE_FIELD_RECORD, секция=" + пДанные['секция']
			сам.слова_секции = пДанные['слова']
		Слова_Проверить()
		сам.__имя = "" # имя записи
		сам.__бЭкспорт = False # экспорт в полях низкого уровня не вычисляется
		сам.__бЭкспорт_бПрисвоено = False # Защёлка присвоения экспорта
		сам.__бЭкспорт = False # бЭкспорт будет выясняться самими силами поля
		сам.__бСсылка_бПрисвоено = False # Защёлка присвоения ссылки
		сам.__бСсылка = False
		сам.__предок = тРод.сБезПредка

		сам.__ИмяПоле_Проверить()
		сам.__Экспорт_Проверить()
		сам.__Двоеточие_Обрезать()
		сам.__Предок_Проверить()

	def __ИмяПоле_Проверить(сам):
		"""
		Проверяет имя поля в записи, должно быть простым.
		Поскольку имён полей с оним типом может быть несколько -- каждое
		поле в группе добавляется под своим номером.
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			сам.__имя = имя
			сам.СловаСекции_Обрезать()

	def __Имя_Проверить(сам):
		"""
		Проверяет имя записи. Должно быть простым именем и
		не должно быть "," или ":".
		Имя НЕ МОЖЕТ быть составным
		"""
		бРезульт = False
		слово_имя = сам.слова_секции[0]
		print("тАнализЗаписьПоле: 8365 имя поля=", слово_имя.строка)
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			сам.СловаСекции_Обрезать()
			сам.__имя = имя
			бРезульт = True
		else:
			assert False, "тАнализЗаписьПоле: имя поля должно быть допустимым именем" + слово_имя.стрИсх

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является ли поле экспортируемым.
		"""
		слово_экспорт = сам.слова_секции[0]
		строка_экспорт = слово_экспорт.Проверить()
		if строка_экспорт == "*": # есть экспорт
			сам.СловаСекции_Обрезать()
			сам.__бЭкспорт = True
		elif строка_экспорт == "," or строка_экспорт == ":":
			pass # это определение списка полей
		else:
			assert False, "тАнализЗаписьПоле: Символ экспорта допустим '*' или '='" + слово_экспорт.стрИсх
		print("тАнализЗаписьПоле: 6795 экспорт поля=", сам.__бЭкспорт)

	def __бЭксорт_Уст(сам, пЭкспорт):
		"""
		Устанавливает экспорт с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пЭкспорт) == BOOLEAN, "тАнализЗаписьПоле: пЭкспорт должен быть BOOLEAN, type=" + str(type(пЭкспорт))
		assert сам.__бЭкспорт_бПрисвоено == False, "тАнализЗаписьПоле: пЭкспорт уже присвоен, экспорт=" + сам.__бЭкспорт
		сам.__бЭкспорт_бПрисвоено = True
		сам.__бЭкспорт = пЭкспорт

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	def __Предок_Проверить(сам):
		"""
		Проверяет предка поля. Должно быть разрешённой строкой.
		конечный символ ";" или ")"
		Кроме того, имя может быть составным
		===== Улучшенная проверенная версия =======
		"""
		слово_предок = сам.слова_секции[0]
		предок = слово_предок.Проверить()
		стрОш = "тАнализЗаписьПоле: имя поля должно быть допустимым именем"
		assert слово_предок.ЕслиСтр_Допустимо(), стрОш + слово_предок.строка + слово_предок.стрИсх
		assert сам.предок != тРод.сБезТипа, "тАнализЗаписьПоле: предок уже назначен  " + сам.предок + слово_предок.стрИсх
		print("тАнализЗаписьПоле: 6009 возможный предок=", предок, слово_предок.стрИсх)
		if предок == "ARRAY": # Предок поля -- массив,обработать отдельно
			print("6709 ARRAY")
			сам.бМассив = True
			парам = {}
			парам['слова']  = сам.слова_секции
			парам['секция'] = "FIELD_ARRAY"
			сам.массив = тАнализТипПолеМассив(парам)
			сам.слова_секции = сам.массив.слова_секции
		elif предок in тРод.тип_встроен:
			print("6709 тип_встроен")
			слово_тип = сам.слова_секции[0]
			строка_тип = слово_тип.Проверить()
			if строка_тип == "BOOLEAN":
				сам.__предок = "BOOL"
			elif строка_тип == "SET":
				сам.__предок = "SET"
			elif строка_тип == "BYTE":
				сам.__предок = "BYTE"
			elif строка_тип == "CHAR":
				сам.__предок = "CHAR"
			elif строка_тип == "INTEGER":
				сам.__предок = "INTEGER"
			elif строка_тип == "REAL":
				сам.__предок = "REAL"
			else:
				assert False, "тАнализЗаписьПоле: Неизвестный типа поля"+слово_тип.стрИсх
			сам.СловаСекции_Обрезать()
			print("6709 ", строка_тип)
			сам.__Разделитель_Обрезать()
		elif предок == "RECORD":
			print("6709 RECORD")
			сам.бМассив = True
			парам = {}
			парам['слова']  = сам.слова_секции
			парам['секция'] = "FIELD_RECORD"
			сам.запись = тАнализЗаписьПоле(парам)
		else:
			сам.__предок = ""
			усл1 = (предок == ".") or (слово_предок.ЕслиСтр_Допустимо())
			усл2 = not (предок == ";") or (предок=="END") or (слово_предок.ЕслиИмя_Строго())
			while True:
				if усл1 and усл2:
					# FIXME: зачем тут обрезать слово -- непонятно?...
					сам.СловаСекции_Обрезать()
					break
				сам.СловаСекции_Обрезать()
				сам.__предок += предок

				слово_предок = сам.слова_секции[0]
				предок = слово_предок.Проверить()
				print("поиск предка в поле: строка=", предок)
				усл1 = (предок == ".") or (слово_предок.ЕслиСтр_Допустимо())
				усл2 = (предок != ";") or (предок!="END") or (not слово_предок.ЕслиИмя_Строго())

	def __Разделитель_Обрезать(сам):
		"""
		В простом поле последнее слово ";" или "END" (* окончание записи *)
		Поэтому его необходимо обрезать
		"""
		слово_раздел = сам.слова_секции[0]
		раздел = слово_раздел.Проверить()
		if раздел == ";":
			сам.СловаСекции_Обрезать()
		elif слово_раздел.строка == "END":
			pass # скобку обрабатывает уровень выше
		else:
			# В типе всегда есть разделитель в конце
			assert False, "тАнализЗаписьПоле: неправильный разделитель типа" + слово_раздел.стрИсх
		print("тАнализЗаписьПоле: 5067 разделитель=", раздел, слово_раздел.стрИсх)

	def Имя_Уст(сам, пИмя):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пИмя) == str, "тАнализЗаписьПоле: пИмя должен быть str, type=" + str(type(пИмя))
		assert пИмя != "", "тАнализЗаписьПоле: пИмя не может быть пустым"
		assert сам.__имя == "", "тАнализЗаписьПоле: имя уже присвоено, имя=" + сам.__имя
		сам.__имя = пИмя

	@property
	def имя(сам):
		return сам.__имя

	def бЭксорт_Уст(сам, пЭкспорт):
		"""
		Устанавливает экспорт с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пЭкспорт) == BOOLEAN, "тАнализЗаписьПоле: пЭкспорт должен быть BOOLEAN, type=" + str(type(пЭкспорт))
		assert сам.__бЭкспорт_бПрисвоено == False, "тАнализЗаписьПоле: пЭкспорт уже присвоен, экспорт=" + сам.__бЭкспорт
		сам.__бЭкспорт_бПрисвоено = True
		сам.__бЭкспорт = пЭкспорт

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	def бСсылка_Уст(сам, пСсылка):
		"""
		Устанавливает ссылку с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пСсылка) == bool, "тАнализЗаписьПоле: пСсылка должен быть BOOLEAN, type=" + str(type(пСсылка))
		assert сам.__бСсылка_бПрисвоено == False, "тАнализЗаписьПоле: пСсылка уже присвоен, экспорт=" + сам.__бСсылка
		сам.__бСсылка_бПрисвоено = True
		сам.__бСсылка = пСсылка

	@property
	def бСсылка(сам):
		return сам.__бСсылка

	def Предок_Уст(сам, пПредок):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		# TODO: имя предка может быть составным
		assert type(пПредок) == str, "тАнализЗаписьПоле: пПредок должен быть str, type=" + str(type(пПредок))
		assert пПредок != "", "тАнализЗаписьПоле: пПредок не может быть пустым"
		assert сам.__предок == тРод.сБезПредка, "тАнализЗаписьПоле: имя уже присвоено, имя=" + сам.__предок
		сам.__предок = пПредок

	@property
	def предок(сам):
		return сам.__предок

	@property
	def имя(сам):
		return сам.__имя

	def __Двоеточие_Обрезать(сам):
		"""
		Здесь может быть только ":"
		"""
		слово_двоеточ = сам.слова_секции[0]
		строка_двоеточ = слово_двоеточ.Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()
		else: # а это уже непонятно что
			assert False, "тАнализЗаписьПоле: разделитель должен быть ':'" + слово_двоеточ.стрИсх
