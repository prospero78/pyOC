# coding: utf8
"""
Описывает процедуру как тип,
а не как блок.
Процедура как тип имеет вид:

SetCompilerFlagProc* = PROCEDURE(VAR pragma, tiles, block: ARRAY OF CHAR);
NotifyErrorProc* = PROCEDURE(pos: INTEGER; msg: ARRAY OF CHAR):BOOLEAN;

Уже рассмотрены имя, экспорт, равно.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакРод.модРод import тРод
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from . модАнализТипБазовый import тАнализТипБазовый

class тАнализТипПроцедура(тАнализТипБазовый):
	def __init__(сам, пДанные):
		тАнализТипБазовый.__init__(сам, пДанные)
		сам.параметры = {} # параметров в поле может быть несколько
		сам.__бСсылка = False # Проверка на VAR в параметрах процедуры
		сам.__предок = "" # Предок параметра в параматерах процедуры
		сам.__СловоПроцедура_Проверить()
		if сам.__СкобкаОткр_Проверить():
			while сам.слова_секции[0].строка != ")":
				while сам.слова_секции[0].строка != ";":
					сам.__Ссылка_Проверить()
					сам.__ЗапятПарам_Получ()
					сам.__Двоеточие_Обрезать()
					сам.__Предок_Проверить()
				сам.__Разделитель_Обрезать()
				сам.__Скобка_Закрыть()
				сам.__Двоеточие_Проверить()
				сам.__Предок_Проверить()
		сам.__Разделитель_Обрезать()

	def __ЗапятПарам_Получ(сам):
		 """
		 Получает список параметров, следующих
		 через запятую
		 """
		 рез = ""
		 while рез != "двоеточ":
			 рез = сам.__ИмяПарам_Проверить()
			 if рез == "запят":
				 сам.__Запятая_Обрезать()

	def __СловоПроцедура_Проверить(сам):
		"""
		Первы должно идти слово "PROCEDURE"
		"""
		слово_проц = сам.слова_секции[0]
		строка_проц = слово_проц.Проверить()
		if строка_проц != "PROCEDURE":
			assert False, "тАнализТипПроцедура: отсуствует кючевое слово 'PROCEDURE'" + слово_проц.стрИсх
		else:
			сам.СловаСекции_Обрезать()

	def __СкобкаОткр_Проверить(сам) -> bool:
		"""
		Процедура может не иметь скобок параметров.
		Надо проверить.
		"""
		бРезульт = False
		слово_скобка = сам.слова_секции[0]
		строка_скоб = слово_скобка.Проверить()
		if строка_скоб == "(": # начало параметров в процедуре
			сам.СловаСекции_Обрезать()
			бРезульт = True
		return бРезульт

	def __ИмяПарам_Проверить(сам):
		"""
		Проверяет имя параметра, должно быть простым.
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			номер = len(сам.параметры)
			сам.параметры[номер] = {}
			сам.параметры[номер]['имя'] = имя
			сам.параметры[номер]['номер'] = номер
			сам.СловаСекции_Обрезать()
			рез = "имя"
		elif имя == ":":
			# Закончилось перечисление имён параметров в заголовке процедуры, дальше тип
			рез = "двоеточ"
		elif имя == ",":
			рез = "запят"
		else:
			assert False, "тАнализТипПроцедура: имя параметра недопустимо" + слово_имя.стрИсх
		return рез

	def __Скобка_Закрыть(сам):
		"""
		Процедура уже точно имеет скобки.
		Надо закрыть параметры
		"""
		бРезульт = False
		слово_скобка = сам.слова_секции[0]
		строка_скоб = слово_скобка.Проверить()
		if строка_скоб == ")": # начало параметров в процедуре
			сам.СловаСекции_Обрезать()
			бРезульт = True
		else:
			assert False, "тАнализТипПроцедура: в параметрах типа-процедуры должна быть скобка закрытия ')'"+ слово_скобка.стрИсх
		return бРезульт

	def __Разделитель_Обрезать(сам):
		"""
		В простых типах последнее слово ";"
		Поэтому его необходимо обрезать
		"""
		слово_имя = сам.слова_секции[0]
		строка_раздел = слово_имя.Проверить()
		if строка_раздел == ";":
			сам.СловаСекции_Обрезать()
		elif строка_раздел == ")":
			pass # окончание слов параметров, не надо обрезать
		else:
			assert строка_раздел != ";", "тАнализТипПроцедура: неправильный разделитель поля" + слово_имя.стрИсх

	def __Предок_Проверить(сам):
		"""
		Проверяет предка параметров процедуры. Должно быть разрешённой строкой.
		Кроме того, имя может быть составным или вообще массивом
		"""
		стрОш = "тАнализТипПроцедура: тип параметра должно быть допустимым именем, имя="
		бРезульт = False
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		assert слово_имя.ЕслиСтр_Допустимо(), стрОш + имя
		предок = ""
		цСчёт = 0
		while True:
			бРезульт = True
			сам.СловаСекции_Обрезать()

			предок += имя
			слово_имя = сам.слова_секции[цСчёт]
			имя = слово_имя.Проверить()

			if (имя == ";") or (имя == ")"):
				# Первого обрезания секции и присвоения имени в цикле -- не случится
				сам.СловаСекции_Обрезать()
				break

			цСчёт += 1
		assert предок != "", "тАнализТипПроцедура: тип параметра не может быть пустой строкой"
		сам.Предок_Уст(предок)
		return бРезульт

	def __Двоеточие_Обрезать(сам):
		"""
		Здесь может быть только ":"
		"""
		слово_двоеточ = сам.слова_секции[0]
		строка_двоеточ = слово_двоеточ.Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()
		else: # а это уже непонятно что
			assert False, "тПроцПараметр: разделитель должен быть ':'" + слово_двоеточ.стрИсх

	def __Двоеточие_Проверить(сам):
		"""
		Здесь может быть ":" (* в конце параметров процедуры *)
		А может и не быть
		"""
		слово_двоеточ = сам.слова_секции[0]
		строка_двоеточ = слово_двоеточ.Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()

	def __Запятая_Обрезать(сам):
		"""
		Проверяет не следует ли запятая за именем параметра.
		(* Праматров при наличии запятой -- несколько *)
		"""
		слово_запятая = сам.слова_секции[0]
		запятая = слово_запятая.Проверить()
		if запятая == ",":
			сам.СловаСекции_Обрезать()

	def __Ссылка_Проверить(сам):
		"""
		Проверяет является ли параметр ссылочным.
		Может быть и имя параметра без ссылки
		"""
		слово_ссылка = сам.слова_секции[0]
		ссылка = слово_ссылка.Проверить()
		if ссылка == "VAR":
			сам.__бСсылка = True
			сам.СловаСекции_Обрезать()

	@property
	def предок(сам):
		return сам.__предок
