# coding: utf8
"""
Описывает процедуру как тип,
а не как блок.
Процедура как тип имеет вид:

SetCompilerFlagProc* = PROCEDURE(VAR pragma, tiles, block: ARRAY OF CHAR);
NotifyErrorProc* = PROCEDURE(pos: INTEGER; msg: ARRAY OF CHAR):BOOLEAN;

Уже рассмотрены имя, экспорт, равно.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакРод.модРод import тРод
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from . модАнализТипБазовый import тАнализТипБазовый
	from .пакАнализТипПроцедура import тАнализТипПарам
	from .пакАнализТипПроцедура import тАнализТипПарамПредок

class тАнализТипПроцедура(тАнализТипБазовый):
	def __init__(сам, пОберон, пДанные):
		сам.__конс = пОберон.конс

		сам.__бОшВнутр = False
		сам.__бОшИсх = False

		тАнализТипБазовый.__init__(сам, пОберон, пДанные)
		if сам.бОшВнутр_АнализТипБазовый:
			сам.__бОшВнутр = True
			стрОш = "тАнализПроцедура.__init__(): ошибка компилятора. При вызове тАнализТипБазовы"
			сам.__конс.ОшВнутр(стрОш)
			return
		сам.параметры = {} # параметров в поле может быть несколько
		сам.__бСсылка = False # Проверка на VAR в параметрах процедуры
		сам.__предок = "" # Предок параметра в параматерах процедуры
		сам.Имя_Проверить()
		сам.бЭкспорт_Проверить()
		сам.Определитель_Проверить()
		сам.__СловоПроцедура_Проверить()
		if сам.__бОшИсх:
			return
		if сам.__СкобкаОткр_Проверить():
			while сам.слова_секции[0].строка != ")":
				парам={}
				парам['слова']=сам.слова_секции

				параметры = тАнализТипПарам(пОберон, парам)
				if параметры.бОшВнутр:
					сам.__бОшВнутр = True
					стрОш = "тАнализПроцедура.__init__(): ошибка компилятора. При вызове тАнализТипПарам"
					сам.__конс.ОшВнутр(стрОш)
					return
				if параметры.бОшИсх:
					сам.__бОшИсх = True
					стрОш = "тАнализПроцедура.__init__(): ошибка исходника. При вызове тАнализТипПарам"
					сам.__конс.Ошибка(стрОш)
					return
				номер = сам.цНомерГруппыПарам - 1
				сам.параметры[номер] = {}
				сам.параметры[номер]['параметры'] = параметры

				сам.слова_секции = {}
				сам.слова_секции = параметры.слова_секции
				параметры.слова_секции = {}

				#========================================
				парам={}
				парам['слова']=сам.слова_секции

				предок = тАнализТипПарамПредок(парам)
				сам.параметры[номер]['предок'] = предок.тип

				сам.слова_секции = {}
				сам.слова_секции = предок.слова_секции
				предок.слова_секции = {}

			сам.__Скобка_Закрыть()
			if сам.__бОшИсх:
				return
			if сам.__ДвоеточиеВозврат_Проверить():
				сам.__Возврат_Проверить()
				if сам.__бОшИсх:
					return
		сам.__Разделитель_Обрезать()
		if сам.__бОшИсх:
				return

	def __ЗапятПарам_Получ(сам):
		"""
		Получает список параметров, следующих
		через запятую
		"""
		рез = ""
		while рез != "двоеточ":
			рез = сам.__ИмяПарам_Проверить()
			if сам.__бОшИсх:
				return
			if рез == "запят":
				сам.__Запятая_Обрезать()

	def __СловоПроцедура_Проверить(сам):
		"""
		Первы должно идти слово "PROCEDURE"
		"""
		слово_проц = сам.слова_секции[0]
		строка_проц = слово_проц.Проверить()
		if строка_проц != "PROCEDURE":
			сам.__бОшИсх = True
			стрОш = "тАнализТипПроцедура: ошибка исходника. Отсуствует кючевое слово 'PROCEDURE'" + слово_проц.стрИсх
			сам.__конс.Ошибка(стрОш)
			return
		else:
			сам.СловаСекции_Обрезать()

	def __СкобкаОткр_Проверить(сам) -> bool:
		"""
		Процедура может не иметь скобок параметров.
		Надо проверить.
		"""
		бРезульт = False
		слово_скобка = сам.слова_секции[0]
		строка_скоб = слово_скобка.Проверить()
		if строка_скоб == "(": # начало параметров в процедуре
			сам.СловаСекции_Обрезать()
			бРезульт = True
		return бРезульт

	def __ИмяПарам_Проверить(сам):
		"""
		Проверяет имя параметра, должно быть простым.
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			номер = len(сам.параметры)
			сам.параметры[номер] = {}
			сам.параметры[номер]['имя'] = имя
			сам.параметры[номер]['номер'] = номер
			сам.СловаСекции_Обрезать()
			рез = "имя"
		elif имя == ":":
			# Закончилось перечисление имён параметров в заголовке процедуры, дальше тип
			рез = "двоеточ"
		elif имя == ",":
			рез = "запят"
		else:
			сам.__бОшИсх = True
			стрОш = "тАнализТипПроцедура: ошибка исходника. Имя параметра недопустимо" + слово_имя.стрИсх
			сам.__конс.Ошибка(стрОш)
			return
		return рез

	def __Скобка_Закрыть(сам):
		"""
		Процедура уже точно имеет скобки.
		Надо закрыть параметры
		"""
		бРезульт = False
		слово_скобка = сам.слова_секции[0]
		строка_скоб = слово_скобка.Проверить()
		if строка_скоб == ")": # начало параметров в процедуре
			сам.СловаСекции_Обрезать()
			бРезульт = True
		else:
			сам.__бОшИсх = True
			стрОш ="тАнализТипПроцедура: ошибка исходника. В параметрах типа-процедуры должна быть скобка закрытия ')'"+ слово_скобка.стрИсх
			сам.__конс.Ошибка(стрОш)
			return
		return бРезульт

	def __Разделитель_Обрезать(сам):
		"""
		В простых типах последнее слово ";"
		Поэтому его необходимо обрезать
		"""
		слово_имя = сам.слова_секции[0]
		строка_раздел = слово_имя.Проверить()
		if строка_раздел == ";":
			сам.СловаСекции_Обрезать()
		elif строка_раздел == ")":
			pass # окончание слов параметров, не надо обрезать
		else:
			сам.__бОшИсх = True
			стрОш = "тАнализТипПроцедура: ошибка исходника. Неправильный разделитель поля" + слово_имя.стрИсх
			сам.__конс.Ошибка(стрОш)
			return

	def __Возврат_Проверить(сам):
		"""
		Проверяет возвращаемый тип результата процедуры. Должно быть разрешённой строкой.
		Тип результата ДОЛЖЕН быть встроенным.
		"""
		слово_резузльт = сам.слова_секции[0]
		стрРезульт = слово_резузльт.Проверить()
		if стрРезульт == "BOOLEAN":
			сам.результ = "BOOLEAN"
			сам.СловаСекции_Обрезать()
		elif стрРезульт == "SET":
			сам.результ = "SET"
			сам.СловаСекции_Обрезать()
		elif стрРезульт == "BYTE":
			сам.результ = "BYTE"
			сам.СловаСекции_Обрезать()
		elif стрРезульт == "CHAR":
			сам.результ = "CHAR"
			сам.СловаСекции_Обрезать()
		elif стрРезульт == "INTEGER":
			сам.результ = "INTEGER"
			сам.СловаСекции_Обрезать()
		elif стрРезульт == "REAL":
			сам.результ = "REAL"
		else:
			сам.__бОшИсх = True
			стрОш = "тАнализТипПроверить: ошибка исходника. Возвращаемый тип должен быть встроенным"+слово_резузльт.стрИсх
			сам.__конс.Ошибка(стрОш)
			return
		if сам.результ == "":
			сам.__бОшИсх = True
			стрОш =  "тАнализТипПроцедура: ошиба исходника. тип параметра не может быть пустой строкой"
			сам.__конс.Ошибка(стрОш)
			return
		сам.СловаСекции_Обрезать()

	def __Двоеточие_Обрезать(сам):
		"""
		Здесь может быть только ":"
		НЕ ИСПОЛЬЗУЕТСЯ
		"""
		слово_двоеточ = сам.слова_секции[0]
		строка_двоеточ = слово_двоеточ.Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()
		else: # а это уже непонятно что
			сам.__бОшИсх = True
			стрОш = "тПроцПараметр: ошибка исходника. Разделитель должен быть ':'" + слово_двоеточ.стрИсх
			сам.__конс.Ошибка(стрОш)
			return

	def __ДвоеточиеВозврат_Проверить(сам):
		"""
		Здесь может быть ":" (* в конце параметров процедуры *)
		А может и не быть
		"""
		бРезульт = False
		слово_двоеточ = сам.слова_секции[0]
		строка_двоеточ = слово_двоеточ.Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()
			бРезульт = True
		return бРезульт

	def __Запятая_Обрезать(сам):
		"""
		Проверяет не следует ли запятая за именем параметра.
		(* Праматров при наличии запятой -- несколько *)
		"""
		слово_запятая = сам.слова_секции[0]
		запятая = слово_запятая.Проверить()
		if запятая == ",":
			сам.СловаСекции_Обрезать()

	def __Ссылка_Проверить(сам):
		"""
		Проверяет является ли параметр ссылочным.
		Может быть и имя параметра без ссылки
		"""
		слово_ссылка = сам.слова_секции[0]
		ссылка = слово_ссылка.Проверить()
		if ссылка == "VAR":
			сам.__бСсылка = True
			сам.СловаСекции_Обрезать()

	@property
	def цНомерГруппыПарам(сам):
		"""
		Возвращает длину словопя параметров процедуры
		"""
		return len(сам.параметры)

	@property
	def предок(сам):
		return сам.__предок

	@property
	def бОшВнутр(сам):
		return сам.__бОшВнутр

	@property
	def бОшИсх(сам):
		return сам.__бОшИсх
