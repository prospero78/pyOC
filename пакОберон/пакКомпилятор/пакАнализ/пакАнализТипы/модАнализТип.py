# coding: utf8
"""
Модуль предоставляет класс для разбора типа.
Простой тип может содержать определения других подтипов и членов.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from пакОберон.пакКомпилятор.пакСущность.пакРод import тРод

	from .модАнализТипБазовый import тАнализТипБазовый
	from . модАнализТипВстроен import тАнализТипВстроен
	from . модАнализТипПерем import тАнализТипПерем
	from . модАнализТипМассив import тАнализТипМассив
	from . модАнализТипЗапись import тАнализТипЗапись
	from . модАнализТипПроцедура import тАнализТипПроцедура

class тАнализТип(тАнализТипБазовый):
	def __init__(сам, пДанные):
		тАнализТипБазовый.__init__(сам, пДанные)
		сам.__род = тРод.сБезРода # Род записи -- один из встроенных, ARRAY, RECORD, PROCEDURE
		сам.__предок = тРод.сБезТипа # Тип предка -- один из наследуемых
		сам.__имя = "" # Временная переменная
		сам.__бУказатель = False # временный признак POINTER TO
		сам.__бЭкспорт = False # Временное хранение экспорта
		сам.массив_тип = тРод.сБезТипа # устанавливает тип массива (если тип -- массив)
		сам.поля = {} # словарь полей типа
		сам.тип = None # ссылка на полученный тип
		assert len(сам.слова_секции) >= 2, "тАнализТип: Неполное определение секции"
		сам.массив_размерность = {} # заполняется при определении массива
		сам.запись_поля = {} # словарь полей типа RECORD

		сам.__индекс = 0 # Смещение в словаре слов
		сам.__Имя_Проверить()     # проверяет имя всех типов
		сам.__Экспорт_Проверить() # проверяет экспортируемый ли тип
		сам.__Определитель_Проверить() # Проверяет литеру "="
		сам.__Указатель_Проверить()    # Проверяет на наличие POINTER TO
		# Проверяет род указателя (массив, процедура, встроенный тип и т. д.)
		сам.__Род_Проверить()

	def __Имя_Проверить(сам):
		"""
		Проверяет имя типа. Должно быть именем и
		не должно быть END.
		Имя НЕ МОЖЕТ быть составным
		"""
		слово_имя = сам.слова_секции[сам.__индекс]
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			сам.__имя = имя
			сам.__индекс += 1
			print("тАнализТип: *** имя типа=", слово_имя.строка)
			#сам.СловаСекции_Обрезать()
		else:
			assert False, "тАнализТип: имя типа должно быть допустимым именем" + слово_имя.стрИсх

	def __Экспорт_Проверить(сам):
		"""
		Проверяет является ли тип экспортируемым.
		"""
		слово_экспорт = сам.слова_секции[сам.__индекс]
		строка_экспорт = слово_экспорт.Проверить()
		if строка_экспорт == "*": # есть экспорт
			#сам.СловаСекции_Обрезать()
			сам.__бЭкспорт = True
			сам.__индекс += 1
		elif строка_экспорт == "=":
			pass # это определение типа
		else:
			assert False, "тАнализТип: Символ экспорта допустим '*' или '='" + слово_экспорт.стрИсх
		print("тАнализТип: *** экспорт типа=", сам.__бЭкспорт)

	def __Определитель_Проверить(сам):
		"""
		Проверяет является ли слово в начале слов секции типа -- "=".
		После обрезания, должно быть первым.
		"""
		слово_опр = сам.слова_секции[сам.__индекс]
		строка_опр = слово_опр.Проверить()
		if слово_опр.род == тСлово.кРавно: # правильное выражение определения типа
			#сам.СловаСекции_Обрезать()
			сам.__индекс += 1
		else: # если определение типа
			assert False, "тАнализТип: Отсутствует определитель \"=\" в объявлении типа" + слово_опр.стрИсх

	def __Указатель_Проверить(сам):
		"""
		Проверяет наличие POINTER TO
		Если тип является указателем, то устанавливается соответствующий признак.
		Иначе, просто пропускается.
		"""
		слово_указ = сам.слова_секции[сам.__индекс]
		строка_указ = слово_указ.Проверить()
		if строка_указ == "POINTER": # модификатор типа, а не сам тип
			print("тАнализТип: *** указатель=", строка_указ)
			#сам.СловаСекции_Обрезать()
			сам.__индекс += 1
			"""
			======== Проверяет, что после POINTER __ОБЯЗАТЕЛЬНО__ TO ==========
			"""
			слово_из = сам.слова_секции[сам.__индекс]
			строка_из = слово_из.Проверить()
			assert строка_из == "TO", "тАнализТип: за POINTER не следует TO" + слово_из.стрИсх
			print("тАнализТип: *** указатель-2 =", строка_из)
			#сам.СловаСекции_Обрезать()
			сам.__бУказатель = True
			сам.__индекс += 1
		else:
			сам.__бУказатель = False # Обязательно принудительно сбросить. Временный признак

	def __ЧастныйПредок_Проверить(сам, пСлово):
		"""
		Проверяет предка записи. Должно быть разрешённой строкой и
		НЕ ДОЛЖНО быть END.
		Кроме того, имя может быть составным
		"""
		# пСлово уже обрезано при рассмотрении типа
		assert type(пСлово) == тСлово, "тАнализТип: пСлово должно быть тСлово, type="+str(type(пСлово))
		стрОш = "тАнализТип: имя типа должно быть допустимым именем"
		assert пСлово.ЕслиСтр_Допустимо(), стрОш + пСлово.строка + пСлово.стрИсх
		assert сам.__предок == тРод.сБезТипа, "тАнализТип: предок уже назначен, предок=" + сам.__предок+ слово_имя.стрИсх
		сам.__предок = ""
		имя = пСлово.Проверить()
		# так как это слово уже обрезано -- пропускаем обрезание словаря
		if (имя == ".") or (пСлово.ЕслиСтр_Допустимо()):
			сам.__предок += имя
			слово_имя = сам.слова_секции[0]
			имя = слово_имя.Проверить()
			бРезульт = True
			сам.СловаСекции_Обрезать()

		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		# проверить до конца имя типа
		while (имя == ".") or (слово_имя.ЕслиСтр_Допустимо()):
			сам.СловаСекции_Обрезать()
			сам.__предок += имя
			слово_имя = сам.слова_секции[0]
			имя = слово_имя.Проверить()
			бРезульт = True
		# теперь надо обрезать окончание типа
		сам.Разделитель_Обрезать()

	def __Род_Проверить(сам):
		"""
		Проверяет род встреченного типа. Возможны варианты:
		1. Алиас встроенного типа.

		2.Массив чего-либо

		3. Пустая запись, должна заканчиваться "END;" (просто запись без членов -- бесполезна,
			но для расширения в шине сообщений -- бывает может пригодиться), скорей всего с
			множеством полей.

		4. Запись с полями, множественные уровни вложенности. Рекурсивный анализ.
			Заканчивается на "END;", но после слова "RECORD" идёт не "END"

		5. ....
		"""

		парам = {}
		парам['секция']  = "анализ"
		парам['слова']   = сам.слова_секции

		print("тАнализТип: *** Длина секции типов =", len(сам.слова_секции))
		слово_тип = сам.слова_секции[сам.__индекс]
		строка_род = слово_тип.Проверить()
		# тип не может начинаться на "." или цифру, или спецсимвол
		assert слово_тип.ЕслиСтр_Допустимо(), "тАнализТип: род типа должен быть допустимым именем" + слово_тип.стрИсх
		if строка_род in тРод.тип_встроен: # текущий тип основан на встроенном типе
			print("*** тАнализТип.род = Тип встроенный", слово_тип.стрИсх)
			сам.тип = тАнализТипВстроен(парам)
		elif строка_род == тРод.сМассив: # текущий тип основан на массиве
			print ("*** тАнализТип.род = Тип массив", слово_тип.стрИсх)
			сам.тип = тАнализТипМассив(парам)
		elif строка_род == тРод.сЗапись: # текущий тип основан на записе
			print("*** тАнализТип.род = Тип запись", слово_тип.стрИсх)
			сам.тип = тАнализТипЗапись(парам)
		elif строка_род == "PROCEDURE": # текущий тип основан на процедуре
			print("*** тАнализТип.род = Тип процедура", слово_тип.стрИсх)
			сам.тип = тАнализТипПроцедура(парам)
		elif слово_тип.ЕслиСтр_Допустимо(): # Пользовательский тип
			print("*** тАнализТип.род = Тип частный = ", слово_тип.строка, слово_тип.стрИсх)
			сам.тип = тАнализТипПерем(парам)
		else:
			assert False, "тАнализТип: неизвестный тип записи" + слово_тип.стрИсх
		if сам.тип == None:
			сам.слова_секции = {}
			сам.слова_секции = сам.__тип.слова_секции
			assert False, "Прерывание в этом месте исходником не предусмотрено, неизвестная ошибка"+слово_тип.стрИсх
		сам.слова_cекции = {}
		сам.слова_секции = сам.тип.слова_секции
		#сам.Предок_Уст(сам.__тип.предок)

	@property
	def имя(сам):
		return сам.__имя

	def Паспорт_Печать(сам):
		print("+ тАнализТип: имя_типа=", сам.имя)
		print("|      экспорт =", сам.тип.бЭкспорт)
		print("|    указатель =", сам.тип.бСсылка)
		print("|       предок =", сам.тип.предок)
		if сам.тип.предок == тРод.сМассив:
			for ключ in range(len(сам.тип.массив_размерность)):
				print("|      ключ ", ключ, ":",сам.тип.массив_размерность[ключ])
			print("|      элем    =", сам.тип.элем)
		elif сам.тип.предок == тРод.сЗапись:
			for ключ in range(len(сам.тип.запись_поля)):
				сам.тип.запись.поля[ключ].Паспорт_Печать()
		print("+" + "-"*35+"\n")
