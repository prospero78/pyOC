# coding:utf8
"""
Содержит базовый тип для всех родов записей
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from пакОберон.пакКомпилятор.пакСущность.пакРод import тРод
	from пакОберон.пакКомпилятор.пакСущность.пакОшибка import тОшибка

class тАнализТипБазовый:
	def __init__(сам, пОберон, пДанные):
		def Слова_Проверить():
			if type(пДанные['слова']) != dict:
				стрОш = "В секцию  должен передаваться словарь слов, type=" + str(type(пДанные['слова']))
				сам.ошб.Внутр("__init__()", стрОш)
				return

			if пДанные['секция'] != "анализ":
				стрОш = "Ошибочное использование типа в секции анализа, секция=" + пДанные['секция']
				сам.ошб.Внутр("__init__()", стрОш)
				return

		сам.__оберон = пОберон
		сам.__конс = пОберон.конс
		сам.__конс.Отладить("тАнализБазовый.__init__()")

		сам.ошб = тОшибка(пОберон, "тАнализТипБазовый")

		Слова_Проверить()
		if сам.ошб.бВнутр:
			return
		сам.слова_секции = пДанные['слова']
		сам.__имя = "" # имя типа
		сам.__бЭкспорт = False # Признак экспорта типа
		сам.__бСсылка_бПрисвоено = False # Защёлка присвоения ссылки
		сам.__бСсылка = False
		сам.__предок = ""
		сам.__бУказатель = False
		сам.элем = "" # Нужно для распознавания массива

	def Имя_Проверить(сам):
		"""
		Проверяет имя типа, должно быть простым.
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		if слово_имя.ЕслиИмя_Строго():
			сам.__имя = имя
			сам.СловаСекции_Обрезать()
		else:
			стрОш = " Имя типа недопустимо="+имя+слово_имя.стрИсх
			сам.ошб.Исх("Имя_Проверить()", стрОш)
			return

	def __Род_Проверить(сам):
		"""
		Устанавливает род типа:
		1. Алиас встроенного типа
		2. Массив
		3. Запись
		4. Указатель
		5. Процедура
		Обрезать слова секции нельзя. Иначе потом не узнаем
		какой тип алиаса используется.
		"""
		тип_встроен = ["BOOLEAN", "CHAR", "INTEGER", "REAL", "BYTE", "SET"]
		строка_род = сам.Слово_Проверить()
		if строка_род in тип_встроен:
			сам.__род = тРод.сВстроен
		elif строка_род == "ARRAY":
			сам.__род = тРод.сМассив
		elif строка_род == "RECORD":
			сам.__род = тРод.сЗапись
		elif строка_род == "POINTER":
			сам.__род = тРод.сУказатель
		elif строка_род == "PROCEDURE":
			сам.__род = тРод.сПроцедура
		else:
			стрОш = "Неизвестный род типа, род="+строка_род
			сам.ошб.Исх("__Род_Проверить()", стрОш)
			return

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	def Предок_Проверить(сам):
		"""
		Проверяет предка типа. Должно быть разрешённой строкой
		Кроме того, имя может быть составным
		У полей два разделителя -- ";" или ")"
		===== Улучшенная проверенная версия =======
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		if not слово_имя.ЕслиСтр_Допустимо():
			стрОш = "Имя типа должно быть допустимым именем"
			стрОш += слово_имя.строка + слово_имя.стрИсх
			сам.ошб.Исх("Предок_Проверить()", стрОш)
			return
		if сам.__предок != "":
			стрОш = "Элемент массива уже назначен  " + сам.элем + слово_имя.стрИсх
			сам.ошб.Исх("Предок_Проверить()", стрОш)
			return
		сам.__предок = ""
		while (имя == ".") or (слово_имя.ЕслиСтр_Допустимо()):
			сам.СловаСекции_Обрезать()
			сам.__предок += имя
			слово_имя = сам.слова_секции[0]
			имя = слово_имя.Проверить()
			 # Такое может быть в определении 1) массива 2) предка записи
			if имя == ";" or имя ==")":
				break
			if not (слово_имя.ЕслиСтр_Допустимо() or имя=="."):
				стрОш = слово_имя.строка + слово_имя.стрИсх
				сам.ошб.Исх("Предок_Проверить()", стрОш)
				return

	def Определитель_Проверить(сам):
		"""
		Проверяет является ли слово в начале слов секции типа -- "=".
		После обрезания, должно быть первым.
		"""
		слово_опр = сам.слова_секции[0]
		строка_опр = слово_опр.Проверить()
		if слово_опр.род == тСлово.кРавно: # правильное выражение определения типа
			сам.СловаСекции_Обрезать()
		else: # если определение типа
			стрОш = "Отсутствует определитель \"=\" в объявлении типа" + слово_опр.стрИсх
			сам.ошб.Исх("Определитель_Проверить()", стрОш)
			return

	def Разделитель_Обрезать(сам):
		"""
		В типах последнее слово ";"
		Поэтому его необходимо обрезать
		"""
		слово_раздел = сам.слова_секции[0]
		раздел = слово_раздел.Проверить()
		if раздел == ";":
			сам.СловаСекции_Обрезать()
		else:
			# В типе всегда есть разделитель в конце
			стрОш =  "Неправильный разделитель типа\";\"=" + раздел + слово_раздел.стрИсх
			сам.ошб.Исх("Разделитель_Обрезать()", стрОш)
			return

	def Имя_Уст(сам, пИмя):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		if type(пИмя) != str:
			стрОш ="пИмя должен быть str, type=" + str(type(пИмя))
			сам.ошб.Внутр("Имя_Уст()", стрОш)
			return
		if пИмя == "":
			сам.ошб.Внутр("Имя_Уст()", "пИмя не может быть пустым")
			return
		if сам.__имя != "":
			стрОш = "Имя уже присвоено, имя=" + сам.__имя
			сам.ошб.Внутр("Имя_Уст()", стрОш)
			return
		сам.__имя = пИмя

	def бЭкспорт_Проверить(сам):
		"""
		Проверяет является ли тип экспортируемым.
		"""
		слово_экспорт = сам.слова_секции[0]
		строка_экспорт = слово_экспорт.Проверить()
		if строка_экспорт == "*": # есть экспорт
			сам.СловаСекции_Обрезать()
			сам.__бЭкспорт = True
		elif строка_экспорт == "=":
			pass # это определение типа
		else:
			стрОш = "Символ экспорта допустим '*' или '='" + слово_экспорт.стрИсх
			сам.ошб.Исх("бЭкспорт_Проверить()", стрОш)
			return

	def бУказатель_Проверить(сам):
		"""
		Проверяет наличие POINTER TO
		Если тип является указателем, то устанавливается соответствующий признак.
		Иначе, просто пропускается.
		"""
		слово_указ = сам.слова_секции[0]
		строка_указ = слово_указ.Проверить()
		if строка_указ == "POINTER": # модификатор типа, а не сам тип
			сам.СловаСекции_Обрезать()
			"""
			======== Проверяет, что после POINTER __ОБЯЗАТЕЛЬНО__ TO ==========
			"""
			слово_из = сам.слова_секции[0]
			строка_из = слово_из.Проверить()
			if строка_из != "TO":
				стрОш = "За POINTER не следует TO" + слово_из.стрИсх
				сам.ошб.Исх("бУказатель_Проверить()", стрОш)
				return
			сам.СловаСекции_Обрезать()
			сам.__бУказатель = True
		else:
			сам.__бУказатель = False # Обязательно принудительно сбросить. Временный признак

	def бЭкспорт_Уст(сам, пЭкспорт):
		"""
		Устанавливает экспорт с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		if type(пЭкспорт) != BOOLEAN:
			стрОш =  "пЭкспорт должен быть BOOLEAN, type=" + str(type(пЭкспорт))
			сам.ошб.Внутр("бЭкспорт_Уст()", стрОш)
			return
		if сам.__бЭкспорт_бПрисвоено != False:
			стрОш = "пЭкспорт уже присвоен, экспорт=" + сам.__бЭкспорт
			сам.ошб.Внутр("бЭкспорт_Уст()", стрОш)
			return
		сам.__бЭкспорт_бПрисвоено = True
		сам.__бЭкспорт = пЭкспорт

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	def бСсылка_Уст(сам, пСсылка):
		"""
		Устанавливает ссылку с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		if type(пСсылка) != bool:
			стрОш = "пСсылка должен быть BOOLEAN, type=" + str(type(пСсылка))
			сам.ошб.Внутр("бСсылка_Уст()", стрОш)
			return
		if сам.__бСсылка_бПрисвоено != False:
			стрОш = "пСсылка уже присвоен, экспорт=" + сам.__бСсылка
			сам.ошб.Внутр("бСсылка_Уст()", стрОш)
			return
		сам.__бСсылка_бПрисвоено = True
		сам.__бСсылка = пСсылка

	@property
	def бСсылка(сам):
		return сам.__бСсылка

	def Предок_Уст(сам, пПредок):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		if type(пПредок) != str:
			стрОш = "пПредок должен быть str, type=" + str(type(пПредок))
			сам.ошб.Внутр("Предок_Уст()", стрОш)
			return
		if пПредок == "":
			стрОш = "пПредок не может быть пустым"
			сам.ошб.Внутр("Предок_Уст()", стрОш)
			return
		if сам.__предок != "":
			стрОш = "Имя уже присвоено, имя=" + сам.__предок
			сам.ошб.Внутр("Предок_Уст()", стрОш)
			return
		сам.__предок = пПредок

	@property
	def бУказатель(сам):
		return сам.__бУказатель

	@property
	def предок(сам):
		return сам.__предок

	@property
	def имя(сам):
		return сам.__имя
