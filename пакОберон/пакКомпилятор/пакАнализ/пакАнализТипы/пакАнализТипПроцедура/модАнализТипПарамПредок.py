# coding: utf8
"""
Модуль анализирует тип группы параметров в процедуре
либо до первого разделителя ";", либо до скобки.
"""

class тАнализТипПарамПредок:
	def __init__(сам, пДанные):
		сам.слова_секции = пДанные['слова']
		сам.тип = "" # Вычисленный тип записи (если массив, то элемент массива)
		сам.бМассив = False # Признак наличия массива
		# 1. Проверяем в порядке следования типов
		сам.__РодТипа_Проверить()
		сам.__Разделитель_Обрезать()

	def __РодТипа_Проверить(сам):
		"""
		Проверяет на род типа. Их может быть несколько.
		1. Встроенный тип
		"""
		слово_тип = сам.слова_секции[0]
		стрТип = слово_тип.Проверить()
		if стрТип == "BOOLEAN":
			сам.тип = "BOOLEAN"
			сам.СловаСекции_Обрезать()
		elif стрТип == "SET":
			сам.тип = "SET"
			сам.СловаСекции_Обрезать()
		elif стрТип == "BYTE":
			сам.тип = "BYTE"
			сам.СловаСекции_Обрезать()
		elif стрТип == "CHAR":
			сам.тип = "CHAR"
			сам.СловаСекции_Обрезать()
		elif стрТип == "INTEGER":
			сам.тип = "INTEGER"
			сам.СловаСекции_Обрезать()
		elif стрТип == "REAL":
			сам.тип = "REAL"
			сам.СловаСекции_Обрезать()
		elif стрТип == "ARRAY":
			сам.бМассив = True
			сам.СловаСекции_Обрезать()
			слово_тип = сам.слова_секции[0]
			стрТип = слово_тип.Проверить()
			if стрТип != "OF":
				assert False, "тАнализТипПарамПредок: Отсутствует OF в определении массива"+слово_тип.стрИсх
			сам.СловаСекции_Обрезать()
			print("9901 OF обрезано")
			# теперь добавить тип элементов массива
			имя_типа = ""
			слово_тип = сам.слова_секции[0]
			while слово_тип.строка != ";" or слово_тип.строка != ")":
				имя_типа += слово_тип.строка
				сам.СловаСекции_Обрезать()
				слово_тип = сам.слова_секции[0]
				стрТип = слово_тип.Проверить()
				if (стрТип == ";" or стрТип == ")"):
					#сам.тип = имя_типа
					print("тАнализТипПарамПредок: 7112 достигнут разделитель предка")
					break
				if not (слово_тип.ЕслиСтр_Допустимо() or стрТип == "."):
					assert False, "тАнализТипПарамПредок: неверное имя предка параметра" + слово_тип.стрИсх
			сам.тип = имя_типа
			print("тАнализТипПарамПредок: 322 тип параметра=", сам.тип)

		# остаётся только частный тип
		elif слово_тип.ЕслиСтр_Допустимо():
			"""
			Гоняем цикл, пока не встретим скобку или разделитель
			"""
			имя_типа = ""
			while слово_тип.строка != ";" or слово_тип.строка != ")":
				имя_типа += слово_тип.строка
				сам.СловоСекции_Обрезать()
				слово_тип = сам.слова_секции[0]
				стрТип = слово_тип.Проверить()
				if (стрТип == ";" or стрТип == ")"):
					сам.тип = имя_типа
					print("тАнализТипПарамПредок: 7142 достигнут разделитель предка")
					break
				if not (слово_тип.ЕслиСтр_Допустимо() or стрТип == "."):
					assert False, "тАнализТипПарамПредок: неверное имя предка параметра" + слово_тип.стрИсх
			#сам.тип = имя_типа
			print("тАнализТипПарамПредок: 644 тип параметра=", сам.тип)

	def __Разделитель_Обрезать(сам):
		"""
		Предок параметра может закончиться, как ";"
		так и ")". Поэтому проверим оба варианта.
		"""
		слово_разд = сам.слова_секции[0]
		стрРаздел = слово_разд.Проверить()
		if стрРаздел == ";":
			сам.СловаСекции_Обрезать()
		elif стрРаздел == ")":
			pass
		else: # А вот тут уже непонятно что
			print("тАнализТипПарамПредок: слово_разд=", слово_разд.стрИсх)
			assert False, "АнализТипПарамПредок: неизвестный символ" + слово_разд.стрИсх

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список
