# coding: utf8
"""
Модуль предоставляет тип для хранения имени модуля и его алиаса.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from пакОберон.пакКомпилятор.пакСущность.пакСекция import тСекцияИмпорт

class тАнализМодуль(тСекцияИмпорт):
	def __init__(сам, пОберон, пДанные:dict)->None:
		сам.__оберон = пОберон
		сам.__конс = пОберон.конс
		сам.__конс.Отладить("тАнализМодуль.__init__()")

		сам.__бОшВнутр = False

		тСекцияИмпорт.__init__(сам, пОберон, пДанные)
		if сам.бОшВнутр_СекцияИмпорт:
			сам.__бОшВнутр = True
			стрОш = "тАнализМодуль.__init__(): ошибка компилятра. При вызове тСекцияИмпорт"
			сам.__конс.ОшВнутр(стрОш)
			return
		#сам.СловаСекции_Печать()
		сам.__стрАлиас :str= "" # Алиас модуля
		сам.__алиас_слово :тСлово # тСлово алиаса
		сам.__имя :str= "" # Настоящее имя модуля
		if сам.__Проверить_Присвоить():     # проверка на наличие алиаса
			сам.__Алиас_Получить()
			сам.__СловаСекции_Обрезать() # литера равно -- признак алиаса
		сам.__Имя_Проверить()  # сложное имя в любом случае алиаса

	def __Алиас_Получить(сам)->None:
		"""
		Выясняет правильность имени модуля.
		"""
		слова_алиас :тСлово= сам.слова_секции[0]
		алиас :str= слова_алиас.Проверить()
		if слова_алиас.ЕслиИмя_Строго():
			сам.__стрАлиас = алиас
			сам.__алиас_слово = слова_алиас
			сам.__СловаСекции_Обрезать()
		else:
			сам.__бОшВнутр = True
			сам.__кос.ОшВнутр("тАнализМодуль: ошибка компилятора. Алиас модуля должно быть допустимым именем, имя=" + алиас + слова_алиас.стрИсх)
			return

	def __Проверить_Присвоить(сам)->bool:
		"""
		Проверяет литеру равно в импорте модулей. Может и не быть
		В словаре слов-- это по счёту ВТОРОЕ слово
		"""
		бРезульт :bool= False
		слово_равно :тСлово= сам.слова_секции[1]
		строка_равно :str= слово_равно.Проверить()
		if слово_равно.род == тСлово.кПрисвоить: # есть уравнивание
			бРезульт = True
		return бРезульт

	def __Имя_Проверить(сам)->None:
		"""
		Пока не встретится "," или ";" -- заполнять имя алиаса
		"""
		def Имя_Проверить():
			"""
			Проверяет чтобы имя было строгим
			"""
			строка :str= слово_имя.строка
			бУсл1 :bool= слово_имя.ЕслиИмя_Строго() or (строка == ".")
			бУсл2 :bool= (строка !=",") and (строка !=";")
			return бУсл1 and бУсл2
		слово_имя :тСлово= сам.слова_секции[0]
		имя :str= слово_имя.Проверить()
		while Имя_Проверить():
			сам.__СловаСекции_Обрезать()
			сам.__имя += имя
			слово_имя = сам.слова_секции[0]
			имя = слово_имя.Проверить()
		сам.__СловаСекции_Обрезать() # Откидываем завершающий разделитель

	def __СловаСекции_Обрезать(сам)->None:
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список :dict= {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	def Паспорт_Печать(сам)->None:
		"""
		Печатает паспорт модуля со всеми атрибутами.
		"""
		сам.__конс.Печать("\n+ Модуль:", сам.__имя)
		if сам.__стрАлиас != "":
			сам.__конс.Печать("|   Алиас \"" + сам.__имя + "\" :=", сам.__алиас_слово.строка)
		сам.__конс.Печать("+"+"-"*35)

	@property
	def стрАлиас(сам)->str:
		return сам.__стрАлиас

	@property
	def имя(сам)->str:
		return сам.__имя

	@property
	def бАлиас(сам)->bool:
		бАлиас = False
		if сам.__стрАлиас != "":
			бАлиас = True
		return бАлиас

	@property
	def бОшВнутр_АнализМодуль(сам):
		return сам.__бОшВнутр
