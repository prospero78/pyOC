# coding:utf8
"""
Модуль для базового типа поля.
Тип поля может быть:
1. Переменные
2. Поля в типах
3. Поля в процедурах.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакРод import тРод

class тПолеБаза:
	def __init__(сам, пДанные):
		def Слова_Проверить():
			бУсл = type(пДанные['слова']) == dict
			стрОш = "тПолеБаза: В секцию  должен передаваться словарь слов, type=" + str(type(пДанные['слова']))
			assert бУсл, стрОш
			if пДанные['секция'] != "VAR":
				assert False, "тПолеБаза: ошибочное использование типа в секции VAR, секция=" + пДанные['секция']
		Слова_Проверить()
		сам.слова_секции = пДанные['слова']
		сам.__имя = пДанные['имя'] # имя в полях низкого уровня не обрабатывается
		сам.__бЭкспорт = пДанные['бЭкспорт'] # эксопрт в полях низкого уровня не вычисляется
		сам.__бЭкспорт_бПрисвоено = False # Защёлка присвоения экспорта
		сам.__бЭкспорт = False # бЭкспорт будет выясняться самими силами поля
		сам.__бСсылка_бПрисвоено = False # Защёлка присвоения ссылки
		сам.__бСсылка = False
		сам.__предок = тРод.сБезПредка

	def __бЭксорт_Уст(сам, пЭкспорт):
		"""
		Устанавливает экспорт с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пЭкспорт) == BOOLEAN, "тПолеБаза: пЭкспорт должен быть BOOLEAN, type=" + str(type(пЭкспорт))
		assert сам.__бЭкспорт_бПрисвоено == False, "тПолеБаза: пЭкспорт уже присвоен, экспорт=" + сам.__бЭкспорт
		сам.__бЭкспорт_бПрисвоено = True
		сам.__бЭкспорт = пЭкспорт

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	def Предок_Проверить(сам):
		"""
		Проверяет предка поля. Должно быть разрешённой строкой.
		конечный символ ";" или ")"
		Кроме того, имя может быть составным
		===== Улучшенная проверенная версия =======
		"""
		слово_предок = сам.слова_секции[0]
		предок = слово_предок.Проверить()
		стрОш = "тПолеБаза: имя поля должно быть допустимым именем"
		assert слово_предок.ЕслиСтр_Допустимо(), стрОш + слово_предок.стрИмя + слово_предок.стрИсх
		assert сам.предок != тРод.сБезТипа, "тПолеБаза: предок уже назначен  " + сам.предок + слово_предок.стрИсх
		print("тПолеБаза: предок=", слово_предок.стрИсх)
		сам.__предок = ""
		усл1 = (предок == ".") or (слово_предок.ЕслиСтр_Допустимо())
		усл2 = not (предок == ";") or (предок==")")
		while True:
			if (not усл1) and усл2:
				break
			сам.СловаСекции_Обрезать()
			сам.__предок += предок
			слово_предок = сам.слова_секции[0]
			предок = слово_предок.Проверить()
			усл1 = (предок == ".") or (слово_предок.ЕслиСтр_Допустимо())
			усл2 = not (предок == ";") or (предок==")")

		#if not (слово_предок.ЕслиСтр_Допустимо() or предок=="."):
		#	assert False, стрОш + слово_предок.строка + слово_предок.стрИсх

	def Разделитель_Обрезать(сам):
		"""
		В полях последнее слово ";" или ")"
		Поэтому его необходимо обрезать
		"""
		слово_раздел = сам.слова_секции[0]
		if слово_раздел.род == тСлово.кТочкаЗапятая:
			сам.СловаСекции_Обрезать()
		elif слово_раздел.строка == ")":
			pass # скобку обрабатывает уровень выше
		else:
			# В типе всегда есть разделитель в конце
			assert False, "тПолеБаза: неправильный разделитель типа" + слово_раздел.стрИсх

	def Имя_Уст(сам, пИмя):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пИмя) == str, "тПолеБаза: пИмя должен быть str, type=" + str(type(пИмя))
		assert пИмя != "", "тПолеБаза: пИмя не может быть пустым"
		assert сам.__имя == "", "тПолеБаза: имя уже присвоено, имя=" + сам.__имя
		сам.__имя = пИмя

	@property
	def имя(сам):
		return сам.__имя

	def бЭксорт_Уст(сам, пЭкспорт):
		"""
		Устанавливает экспорт с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пЭкспорт) == BOOLEAN, "тПолеБаза: пЭкспорт должен быть BOOLEAN, type=" + str(type(пЭкспорт))
		assert сам.__бЭкспорт_бПрисвоено == False, "тПолеБаза: пЭкспорт уже присвоен, экспорт=" + сам.__бЭкспорт
		сам.__бЭкспорт_бПрисвоено = True
		сам.__бЭкспорт = пЭкспорт

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	def бСсылка_Уст(сам, пСсылка):
		"""
		Устанавливает ссылку с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пСсылка) == bool, "тПолеБаза: пСсылка должен быть BOOLEAN, type=" + str(type(пСсылка))
		assert сам.__бСсылка_бПрисвоено == False, "тПолеБаза: пСсылка уже присвоен, экспорт=" + сам.__бСсылка
		сам.__бСсылка_бПрисвоено = True
		сам.__бСсылка = пСсылка

	@property
	def бСсылка(сам):
		return сам.__бСсылка

	def Предок_Уст(сам, пПредок):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		# TODO: имя предка может быть составным
		assert type(пПредок) == str, "тПолеБаза: пПредок должен быть str, type=" + str(type(пПредок))
		assert пПредок != "", "тПолеБаза: пПредок не может быть пустым"
		assert сам.__предок == тРод.сБезПредка, "тПолеБаза: имя уже присвоено, имя=" + сам.__предок
		сам.__предок = пПредок

	@property
	def предок(сам):
		return сам.__предок

	def Имя_Уст(сам, пИмя):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пИмя) == str, "тПолеБаза: пИмя должен быть str, type=" + str(type(пИмя))
		assert пИмя != "", "тПолеБаза: пИмя не может быть пустым"
		assert сам.__имя == "", "тПолеБаза: имя уже присвоено, имя=" + сам.__имя
		сам.__имя = пИмя

	@property
	def имя(сам):
		return сам.__имя
