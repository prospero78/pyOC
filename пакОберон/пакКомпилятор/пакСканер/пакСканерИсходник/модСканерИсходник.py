# coding: utf8
"""
Модуль предоставляет тип Исходника.
Производит первоначальное чтение, разбивает на типовые цепочки литер,
отбрасывает мусор
"""

if True:
	from numba import jit #type:ignore
	from пакОберон.пакКомпилятор.пакСущность.пакКоорд import тКоордФикс, тКоордИзм
	from .модСканерИсхСтроки import тСканерИсхСтроки
	from .модСканерИсхТекст import тСканерИсхТекст
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово

class тСканерИсходник:
	def __init__(сам, пОберон:str, пИмяФайла : str)->None:
		def ИмяФайла_Проверить()->bool:
			"""
			1. Имя файла должно быть строкой
			2. Имя файла не может быть пустым
			"""
			############## 1 ##########
			if type(пИмяФайла) != str:
				стрСообщ :str = "тИсходник.__init__(): пИмяФайла должно быть строкой, type(пИмяФайла)=" + \
						str(type(пИмяФайла))
				сам.__конс.ОшВнутр(стрСообщ)
				return True
			############ 2 ############
			if пИмяФайла == "":
				стрСообщ = "тИсходник.__init__(): пИмяФайла не должно быть пустым"
				сам.__конс.ОшВнутр(стрСообщ)
				return True
			return False

		сам.__оберон = пОберон
		сам.__конс = пОберон.конс
		if ИмяФайла_Проверить():
			сам.__конс.ОшВнутр("тСМканерИсходник.__init__(): ошибка имени файла")
			return

		сам.__исх  :тСканерИсхТекст = тСканерИсхТекст(пОберон, пИмяФайла)   # хранит текст исходного кода
		сам.строки :тСканерИсхСтроки = тСканерИсхСтроки(пОберон, сам.__исх())# хранит строки исходного текста
		сам.слова_модуля :dict = {}      # словарь слов в тексте
		сам.коорд :тКоордИзм= тКоордИзм(пОберон, 1, 0) # общая позиция в исходном тексте
		сам.__указ :int= 0          # бегунок в исходнике
		сам.модуль    = None    # модуль слов для компиляции
		сам.__Обработать()

	@jit(nogil=True, cache=True)
	def __Слово_Добав(сам, пСлово : тСлово)->None:
		"""
		Процедура добавляет слово с атрибутами положения в исходном тексте.
		Строки исходника остаются отдельно.
		"""
		слово :тСлово= тСлово(сам.__оберон, сам, пСлово)
		сам.слова_модуля[сам.цСловаВсего] = слово
		сам.коорд.Поз_Доб()

	def НаСлова_Разделить(сам)->None:
		def Пробел(лит:str)->None:
			if лит == ' ':
				сам.коорд.Поз_Доб()
			elif лит == '\t':
				for i in range(3):
					сам.коорд.Поз_Доб()
		def Запятая(лит:str)->None:
			if лит ==',':
				сам.__Слово_Добав(',')
		def ТочкаЗапятая(лит:str)->None:
			if лит == ';':
				сам.__Слово_Добав(';')
		def Плюс(лит:str)->None:
			if лит == '+':
				сам.__Слово_Добав('+', )
		def Минус(лит:str)->None:
			if лит == '-':
				сам.__Слово_Добав('-')
		def Деление(лит:str)->None:
			if лит == '/':
				сам.__Слово_Добав('/')
		def ЛеваяСкобка(лит:str)->None:
			if лит == '(':
				if лит + сам.__исх.Лит(сам.__указ+1) != "(*":
					сам.__Слово_Добав('(')
				else:
					сам.__Слово_Добав('(*')
					сам.коорд.Поз_Доб()
					сам.__указ += 1
		def ПраваяСкобка(лит:str)->None:
			if лит == ')':
				сам.__Слово_Добав(')')
		def НоваяСтрока(лит:str)->None:
			if лит == '\n':
				сам.коорд.Стр_Доб()
				сам.коорд.Поз_Сброс()
		def Умножить(лит:str)->None:
			if лит == '*':
				if лит + сам.__исх.Лит(сам.__указ+1) == "*)":
					сам.__Слово_Добав('*)')
					сам.коорд.Поз_Доб()
					сам.__указ += 1
				else:
					сам.__Слово_Добав('*')
		def Двоеточие(лит:str)->None:
			if лит == ':':
				if лит + сам.__исх.Лит(сам.__указ+1) == ":=":
					сам.__Слово_Добав(':=')
					сам.коорд.Поз_Доб()
					сам.__указ += 1
				else:
					сам.__Слово_Добав(':')
		def ПереводКаретки(лит:str)->None:
			if лит == '\r':
				сам.коорд.цПоз += 1
		def ЕслиСущность(лит:str)->None:
			"""
			Если началось число или имя сущности.
			"""
			# если "_" или буква -- то это только имя
			сущн :str= ""
			if лит=="_" or лит.isalpha():
				while лит.isalpha() or лит.isdigit() or лит=="_":
					сущн += лит
					сам.__указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.__указ)
				else:
					# откат на одну позицию
					сам.__указ -= 1
					сам.коорд.цПоз = сам.коорд.цПоз - len(сущн)
					сам.__Слово_Добав(сущн)
					сам.коорд.цПоз = сам.коорд.цПоз + len(сущн)-1

			# возможно это число
			elif лит.isdigit():
				while лит.isdigit() or лит == ".":
					сущн += лит
					сам.__указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.__указ)
				else:
					# откат на одну позицию
					сам.__указ -= 1
					сам.коорд.цПоз = сам.коорд.цПоз - len(сущн)
					сам.__Слово_Добав(сущн)
					сам.коорд.цПоз = сам.коорд.цПоз + len(сущн)-1
		def Равно(лит:str)->None:
			if лит =='=':
				сам.__Слово_Добав('=')
		def Точка(лит:str)->None:
			if лит =='.':
				сам.__Слово_Добав('.')
		def Кавычка2(лит:str)->None:
			"""
			Вычисляет строки.
			"""
			if лит == '"':
				стр :str= '"'
				лит = ""
				while лит !='"':
					сам.__указ += 1
					сам.коорд.Поз_Доб()
					лит = сам.__исх.Лит(сам.__указ)
					стр += лит
				сам.__Слово_Добав(стр)
				сам.коорд.Поз_Доб()

		исх_длина :int = сам.__исх.длина - 1
		while сам.__указ-1 < исх_длина:
			лит = сам.__исх.Лит(сам.__указ)
			Пробел(лит)
			Запятая(лит)
			ТочкаЗапятая(лит)
			ЛеваяСкобка(лит)
			ПраваяСкобка(лит)
			НоваяСтрока(лит)
			Умножить(лит)
			Двоеточие(лит)
			ПереводКаретки(лит)
			ЕслиСущность(лит)
			Равно(лит)
			Точка(лит)
			Кавычка2(лит)
			Плюс(лит)
			Минус(лит)
			Деление(лит)
			сам.__указ += 1

	@jit(nogil=True, cache=True)
	def СловаМодуля_Печать(сам)->None:
		сам.__конс.Печать("тСканерИсходник: всего слов модуля", сам.цСловаВсего)
		for ключ in сам.слова_модуля:
			слово :тСлово = сам.слова_модуля[ключ]
			сам.__конс.Печать(слово)

	@jit(nogil=True, cache=True)
	def Парам_Получ(сам) -> dict:
		парам :dict= {}
		парам['секция'] = "MODULE"
		парам['слова'] = сам.слова_модуля #type:ignore
		парам['слова_секции'] = {} #type:ignore
		return парам

	def Комментарии_Выкинуть(сам)->None:
		"""
		Выкидывать по кругу комментарии, пока не будут выкинуты полностью.
		"""
		def Коммент_Выкинуть():
			"""
			Нагло выкидывает комментарий из слов.
			Должен контролировать непарное открытие и закрытие комментариев.
			"""
			бКоммент :bool= False
			лцСловоНомер :int= 0
			лцНомерЧистый :int= 0
			слова :dict= {} # чистый список слов
			лцУровень :int= 0 # уровен вложенных комментариев
			while лцСловоНомер < len(сам.слова_модуля):
				слово :тСлово= сам.слова_модуля[лцСловоНомер]
				if слово.строка == "(*": # начался пропуск слов
					бКоммент = True
					лцУровень += 1
				elif слово.строка == "*)":
					лцУровень -= 1

				# пропуск слов внутри комментария
				if лцУровень == 0 and слово.строка != "*)":
					слова[лцНомерЧистый] = слово
					лцНомерЧистый += 1

				лцСловоНомер += 1

			# проверка на сбалансированность уровня вложения
			if лцУровень != 0:
				стрСообщ :str= "Открытие и закрытие комментариев в модуле не сбалансировано, лцУровень=" + str(лцУровень)
				сам.__конс.Ошибка(бУсл, стрСообщ)
				return False

			сам.слова_модуля = слова
			return бКоммент
		while Коммент_Выкинуть():
			pass

	def __Обработать(сам)->None:
		#сам.строки.ПоСтр_Печать()
		сам.НаСлова_Разделить()
		#сам.Слова_Печать()
		сам.Комментарии_Выкинуть()
		#сам.__конс.Печать("===Чистые слова===")
		#сам.Слова_Печать()

	@property
	def цСловаВсего(сам)->int:
		return len(сам.слова_модуля)
