# coding: utf8
"""
Модуль предоставляет тип для хранения строк исходника.
"""
class тСканерИсхСтроки:
	def __init__(сам, пОберон, пИсхКод:str)->None:
		def НаСтроки_Разбить():
			"""
			Берёт исходный тест и разбивает на строки
			"""
			лит :str= ""
			строка :str= ""
			for лит in сам.__исх:
				if лит == '\n':
					сам.__строки[сам.__стр_всего] = строка
					сам.__стр_всего += 1
					строка = ""
				else:
					строка += лит

		сам.__оберон = пОберон
		сам.__конс = пОберон.конс
		if type(пИсхКод) != str:
			стрСообщ = "тИсхСтроки.__init__(), тип исходника не строка, type(пИсхКод)=" + str(type(пИсхКод))
			сам.__конс.ОшВнутр(стрСообщ)
			return

		сам.__исх :str= пИсхКод

		сам.__строки :dict= {}
		сам.__стр_всего :int =1

		НаСтроки_Разбить()

		#сам.ПоСтр_Печать()

	def ПоСтр_Печать(сам)->None:
		цСчётчик :int = 1
		while цСчётчик < сам.__стр_всего:
			стрНомерСтроки :str = str(цСчётчик)
			while len(стрНомерСтроки) < 2:
				стрНомерСтроки = "0" + стрНомерСтроки
			сам.__конс.Отладить(стрНомерСтроки + " " + сам.__строки[цСчётчик])
			цСчётчик += 1

	def __call__(сам, пцНомер:int)->str:
		if type(пцНомер) != int:
			стрСообщ :str = "тИсхСтроки.__call__(), тип номера строки не целое, type(пцНомер)=" + str(type(пцНомер))
			сам.__конс.ОшВнутр(стрСообщ)
			return ""
		return сам.__строки[пцНомер]

	@property
	def всего(сам)->int:
		return len(сам.__строки)
