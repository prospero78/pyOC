# coding: utf8
"""
Модуль предоставляет тип для хранения строк исходника.
"""

from пакОберон.пакКомпилятор.пакСущность.пакОшибка import тОшибка

class тСканерИсхСтроки:
	def __init__(сам, пОберон, пИсхКод:str)->None:
		def НаСтроки_Разбить()->None:
			"""
			Берёт исходный тест и разбивает на строки
			"""
			лит :str= ""
			строка :str= ""
			for лит in сам.__исх:
				if лит == '\n':
					сам.__строки[сам.__стр_всего] = строка
					сам.__стр_всего += 1
					строка = ""
				else:
					строка += лит

		сам.__оберон = пОберон
		сам.__конс = пОберон.конс
		сам.__конс.Отладить("тСканерИсхСтроки.__init__()")

		сам.ош = тОшибка(пОберон, "тСканерИсхСтроки")

		if type(пИсхКод) != str:
			стрСообщ = "Тип пИсхКод не str, type=" + str(type(пИсхКод))
			сам.ош.Внутр("__init__()", стрСообщ)
			return

		if пИсхКод == "":
			сам.ош.Внутр("__init__()", "пИсхКод не может быть пустой строкой")
			return

		сам.__исх :str= пИсхКод

		сам.__строки :dict= {}
		сам.__стр_всего :int =1

		НаСтроки_Разбить()

	def ПоСтр_Печать(сам)->None:
		цСчётчик :int = 1
		while цСчётчик < сам.__стр_всего:
			стрНомерСтроки :str = str(цСчётчик)
			while len(стрНомерСтроки) < 2:
				стрНомерСтроки = "0" + стрНомерСтроки
			сам.__конс.Отладить(стрНомерСтроки + " " + сам.__строки[цСчётчик])
			цСчётчик += 1

	def __call__(сам, пцНомер:int)->str:
		if type(пцНомер) != int:
			стрСообщ :str = "Тип пцНомер строки не целое, type=" + str(type(пцНомер))
			сам.ош.Внутр("__call__()", стрСообщ)
			return ""

		if пцНомер <= 0:
			сам.ош.Внутр("__call__()", "пцНомер строки не может быть меньше 1")
			return ""

		return сам.__строки[пцНомер]

	@property
	def бОшВнутр(сам):
		return сам.__бОшВнутр

	@property
	def всего(сам)->int:
		return len(сам.__строки)
