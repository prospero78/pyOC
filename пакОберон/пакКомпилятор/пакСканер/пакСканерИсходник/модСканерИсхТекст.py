# coding: utf8
"""
Обеспечивает хранение исходного текста и его обработку.
"""

#from numba import jit #type:ignore
from пакОберон.пакКомпилятор.пакСущность.пакОшибка import тОшибка

class тСканерИсхТекст:
	def __init__(сам, пОберон, пИмяФайла:str) -> None:
		def Исх_Загрузить():
			if type(пИмяФайла) != str:
				стрОш = "пИмяФайла должно быть строкой, type(пИмяФайла)=" + str(type(пИмяФайла))
				сам.ош.Внутр("__init__()", стрОш)
				return

			if пИмяФайла == "":
				сам.__конс.ОшВнутр("__init__()", "пИмяФайла не должно быть пустым")
				return

			try:
				файл = open(сам.__стрИмя_файла,'r', encoding='utf-8')
				сам.__стрИсх :str= файл.read()
				сам.__стрИсх = сам.__стрИсх.replace("\t", "   ")
				файл.close()
			except:
				стрОш :str= "Не могу загрузить файл " + сам.__стрИмя_файла
				сам.__конс.ОшВнутр("__init__()", стрОш)

		сам.__оберон = пОберон
		сам.__конс = пОберон.конс
		сам.__конс.Отладить("тСканерИсхТекст.__init__()")

		сам.ош = тОшибка(пОберон, "тСканерИсхТекст")

		сам.__стрИсх = ""
		сам.__стрИмя_файла = пИмяФайла

		Исх_Загрузить()
		if сам.ош.бВнутр:
			сам.ош.Внутр("__init__()", "При загрузке файла")
			return
		if len(сам.__стрИсх) < 10:
			стрОш = "Длина текста меньше 10 литер" + "\n\"" + сам.__стрИсх + "\""
			сам.ош.Исх("__init__()", стрОш)
			return

	@property
	def бОшВнутр(сам)->bool:
		return сам.ош.бВнутр

	@property
	def бОшИсх(сам)->bool:
		return сам.ош.бИсх

	#@jit
	def Лит(сам, цПоз:int) -> str:
		"""
		Возвращает позицию литеры в строке
		"""
		if type(цПоз) !=int:
			стрОш = "цПоз должен быть Int, type="+str(type(цПоз))
			сам.ош.Внутр("ит()", стрОш)
			return ""
		if цПоз < 0:
			сам.ош.Внутр("Лит()", "цПоз должен быть больше 0")
			return ""
		return сам.__стрИсх[цПоз]

	@property
	def стрИсх(сам) -> str:
		return сам.__стрИсх

	@property
	def длина(сам) -> int:
		"""
		Возвращает число литер в исходнике
		"""
		return len(сам.__стрИсх)
