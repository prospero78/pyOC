# coding:utf8
"""
Содержит базовый тип для всех родов записей
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from пакОберон.пакКомпилятор.пакСущность.пакРод import тРод

class тТипБазовый:
	def __init__(сам, пДанные):
		def Слова_Проверить():
			бУсл = type(пДанные['слова']) == dict
			стрОш = "В секцию  должен передаваться словарь слов, type=" + str(type(пДанные['слова']))
			assert бУсл, стрОш
		Слова_Проверить()
		if пДанные['секция'] != "TYPE":
			assert False, "тПроцБазовая: ошибочное использование типа в секции TYPE, секция=" + пДанные['секция']
		сам.слова_секции = пДанные['слова']
		сам.__имя = пДанные['имя']
		сам.__бЭкспорт_бПрисвоено = False # Защёлка присвоениЯ экспорта
		сам.__бЭкспорт = пДанные['бЭкспорт']
		сам.__бСсылка_бПрисвоено = False # Защёлка присвоения ссылки
		сам.__бСсылка = False
		сам.__предок = тРод.сБезПредка

	def Ошибка_Печать(сам, пСлово, пСообщ):
		строка_исх = сам.__корень.исх.строки(пСлово.коорд.стр)
		сам.консоль.Печать(сам.__корень.исх.строки(пСлово.коорд.стр))
		сам.ошибка.Коорд(пСообщ, пСлово.коорд, пСлово.строка)

	def __Род_Проверить(сам):
		"""
		Устанавливает род типа:
		1. Алиас встроенного типа
		2. Массив
		3. Запись
		4. Указатель
		5. Процедура
		Обрезать слова секции нельзя. Иначе потом не узнаем
		какой тип алиаса используется.
		"""
		тип_встроен = ["BOOLEAN", "CHAR", "INTEGER", "REAL", "BYTE", "SET"]
		строка_род = сам.Слово_Проверить()
		if строка_род in тип_встроен:
			сам.__род = тРод.сВстроен
		elif строка_род == "ARRAY":
			сам.__род = тРод.сМассив
		elif строка_род == "RECORD":
			сам.__род = тРод.сЗапись
		elif строка_род == "POINTER":
			сам.__род = тРод.сУказатель
		elif строка_род == "PROCEDURE":
			сам.__род = тРод.сПроцедура
		else:
			assert False, "тТипБазовый: Неизвестный род типа, род="+строка_род

	def СловаСекции_Обрезать(сам):
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список = {}
		for ключ in range(1, len(сам.слова_секции)):
			новый_список[ключ-1]=сам.слова_секции[ключ]
		сам.слова_секции = {}
		сам.слова_секции = новый_список

	def Предок_Проверить(сам):
		"""
		Проверяет предка массива. Должно быть разрешённой строкой и
		не должно быть END.
		Кроме того, имя может быть составным
		===== Улучшенная проверенная версия =======
		"""
		слово_имя = сам.слова_секции[0]
		имя = слово_имя.Проверить()
		стрОш = "тТипБазовый: имя типа должно быть допустимым именем"
		assert слово_имя.ЕслиСтр_Допустимо(), стрОш + слово_имя.стрИмя + слово_имя.стрИсх
		assert сам.элем == тРод.сБезТипа, "тТипБазовый: элемент массива уже назначен  " + сам.элем + слово_имя.стрИсх
		сам.__предок = ""
		while (имя == ".") or (слово_имя.ЕслиСтр_Допустимо()):
			сам.СловаСекции_Обрезать()
			сам.__предок += имя
			слово_имя = сам.слова_секции[0]
			имя = слово_имя.Проверить()
			if not (слово_имя.ЕслиСтр_Допустимо() or имя=="."):
				assert False, стрОш + слово_имя.стрИмя + слово_имя.стрИсх

	def Разделитель_Обрезать(сам):
		"""
		В типах последнее слово ";"
		Поэтому его необходимо обрезать
		"""
		слово_раздел = сам.слова_секции[0]
		if слово_раздел.род == тСлово.кТочкаЗапятая:
			сам.СловаСекции_Обрезать()
		else:
			# В типе всегда есть разделитель в конце
			assert False, "тТипБазовый: неправильный разделитель типа" + слово_раздел.стрИсх

	def Имя_Уст(сам, пИмя):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пИмя) == str, "тТипБазовый: пИмя должен быть str, type=" + str(type(пИмя))
		assert пИмя != "", "тТипБазовый: пИмя не может быть пустым"
		assert сам.__имя == "", "тТипБазовый: имя уже присвоено, имя=" + сам.__имя
		сам.__имя = пИмя

	@property
	def имя(сам):
		return сам.__имя

	def бЭксорт_Уст(сам, пЭкспорт):
		"""
		Устанавливает экспорт с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пЭкспорт) == BOOLEAN, "тТипБазовый: пЭкспорт должен быть BOOLEAN, type=" + str(type(пЭкспорт))
		assert сам.__бЭкспорт_бПрисвоено == False, "тТипБазовый: пЭкспорт уже присвоен, экспорт=" + сам.__бЭкспорт
		сам.__бЭкспорт_бПрисвоено = True
		сам.__бЭкспорт = пЭкспорт

	@property
	def бЭкспорт(сам):
		return сам.__бЭкспорт

	def бСсылка_Уст(сам, пСсылка):
		"""
		Устанавливает ссылку с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пСсылка) == bool, "тТипБазовый: пСсылка должен быть BOOLEAN, type=" + str(type(пСсылка))
		assert сам.__бСсылка_бПрисвоено == False, "тТипБазовый: пСсылка уже присвоен, экспорт=" + сам.__бСсылка
		сам.__бСсылка_бПрисвоено = True
		сам.__бСсылка = пСсылка

	@property
	def бСсылка(сам):
		return сам.__бСсылка

	def Предок_Уст(сам, пПредок):
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пПредок) == str, "тТипБазовый: пПредок должен быть str, type=" + str(type(пПредок))
		assert пПредок != "", "тТипБазовый: пПредок не может быть пустым"
		assert сам.__предок == тРод.сБезПредка, "тТипБазовый: имя уже присвоено, имя=" + сам.__предок
		сам.__предок = пПредок

	@property
	def предок(сам):
		return сам.__предок
