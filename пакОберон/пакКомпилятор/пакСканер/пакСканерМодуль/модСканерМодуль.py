# coding: utf8
"""
Модуль предоставляет тип тМодуль.
Содержит процедуры по разбору модуля.

Модуль -- это контейнер с жёсткой структурой.
Обязательно содержит:
1. Заголовок модуля
2. Окончание модуля.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from пакОберон.пакКомпилятор.пакСущность.пакСекция import тСекцияМодуль
	from пакОберон.пакКомпилятор.пакСущность.пакОшибка import тОшибка

class тСканерМодуль(тСекцияМодуль):
	"""
	Тип представляет иерархию модуля с секциями.
	"""
	__slots__ = ("__конс", "ош_", "__имя", "__бМодульОдин", "__импорт", "__конст", \
				"__типы", "__перем", "__проц", "__начало", "__сущн_модули", "__сущн_конст", \
				"__сущн_типы", "__сущн_перем", "__сущн_проц", "__бМодульГотов", \
				"__бИмяПроверить")
	def __init__(сам, пОберон, пДанные:dict)->None:
		сам.__конс = пОберон.конс
		сам.__конс.Отладить("тСканерМодуль.__init__()")

		сам.ош_ = тОшибка(пОберон, "тСканерМодуль")

		тСекцияМодуль.__init__(сам, пОберон, пДанные)
		if сам.ошм.бВнутр:
			return
		if сам.ошм.бИсх:
			return

		сам.__имя :str = "" # Имя текущего модуля
		# содержимое словаря не контролируется
		сам.__бМодульОдин :bool = False # Признак, что MODULE встречается один раз

		сам.__бНачалоМодуль_Готово = False # Признак нахождения начала модуля

		сам.__бМодульГотов = False # Признак полного сканирования модуля
		сам.__бИмяПроверить = False # Признак распознания имени модуля

		#сам.импорт = тИмпорт(сам.слова_модуля)
		сам.__импорт :dict= {} # словари слов импорта
		сам.__конст  :dict= {} # словари слов констант
		сам.__типы   :dict= {} # словари слов типов
		сам.__перем  :dict= {} # словари слов переменных
		сам.__проц   :dict= {} # словари слов процедур
		сам.__начало :dict= {} # словари слов в корне модуля

		сам.__сущн_модули :dict= {} # распознанные сущности импортируемых модулей
		сам.__сущн_конст  :dict= {} # распознанные сущности констант
		сам.__сущн_типы   :dict= {} # распознанные сущности модулей
		сам.__сущн_перем  :dict= {} # распознанные сущности переменных
		сам.__сущн_проц   :dict= {} # распознанные сущности процедур


	def __Имя_Проверить()->None:
		"""
		Второе слово должно быть правильное имя модуля.
		"""
		слово :тСлово= сам.слова_модуля[0]
		стрИмя = слово.строка
		if слово.ош.бВнутр:
			сам.ош_.Внутр("Имя_Проверить()", "При проверке слова")
			return
		if not слово.ЕслиИмя_Строго():
			стрСообщ =  "Нарушение имени модуля "+слово.стрИсх
			сам.ош_.Исх("Имя_Проверить()", стрСообщ)
			return
		# запомним имя модуля
		сам.__имя = слово.строка
		сам.__СловаМодуля_Обрезать()
		сам.__бИмяПроверить = True

	_ def НачалоРазделитель_Проверить()->None:
			"""
			Третьим тегом идёт окончание заголовка модуля.
			"""
			слово :тСлово= сам.слова_модуля[0]
			стрРаздел = слово.строка
			if слово.ош.бВнутр:
				сам.ош_.Внутр("НачалоРазделитель_Проверить()", "При проверке слова")
				return
			if стрРаздел != ";":
				стрСообщ = "Нарушение в окончании имени модуля"+слово.стрИсх
				сам.ош_.Исх("НачалоРазделитель_Проверить()", стрСообщ)
			сам.__СловаМодуля_Обрезать()

		def КонецМодуль_Найти()->None:
			"""
			Вычисляет окончание модуля.
			"""
			цСчётОбр :int= сам.цСловаМодуля-1
			while цСчётОбр >= 0:
				слово_точка :тСлово= сам.слова_модуля[цСчётОбр]
				стрТочка :str= слово_точка.строка
				if слово_точка.ош.бВнутр:
					сам.ош_.Внутр("КонецМодуль_Найти()", "При проверке слова")
					return
				# Между ними -- возможно имя модуля
				цСловоКонец = цСчётОбр-2
				if цСловоКонец < 0:
					сам.ош_.Внутр("КонецМодуль_Найти()", "Выход за пределы словаря слов")
					return
				слово_конец :тСлово= сам.слова_модуля[цСловоКонец]
				стрКонец :str= слово_конец.строка
				if стрТочка == "." and стрКонец == "END":
					слово_имя :тСлово = сам.слова_модуля[цСчётОбр-1]
					стрИмя :str= слово_имя.строка
					if стрИмя == сам.__имя:
						сам.Конец_Уст(сам.слова_модуля[цСчётОбр-2])
						break
					else: # имя модуля в начале и конце -- не совпало
						стрСообщ = "Имя модуля не совпадает, модуль=\""+сам.__имя + \
									"\" " + слово_имя.стрИсх
						сам.ош_.Исх("КонецМодуль_Найти()", стрСообщ)
						return
				цСчётОбр -= 1

			if цСчётОбр == -1:
				стрСообщ = "Нет окончания модуля "+сам.__имя
				сам.ош_.Исх("КонецМодуль_Найти()", стрСообщ)
				return

			# теперь отбросим окончание модуля.
			счёт_новый :int= 0
			слова :dict = {}
			# Исключаем концовку модуля (END MyModule.)
			for счёт in range(0, цСчётОбр-2):
				слово = сам.слова_модуля[счёт]
				слова[счёт_новый] = слово
				счёт_новый += 1
			сам.слова_модуля = слова
		def МодульОдин_Проверить():
			# Слово MODULE должно быть одно.
			счётчик_модуль :int= 0
			for номер_тега in сам.слова_модуля:
				слово :тСлово= сам.слова_модуля[номер_тега]
				if type(слово) != тСлово:
					стрСообщ = "Слово должно быть тСлово, type="+type(слово)
					сам.ош_.Внутр("МодульОдин_Проверить()", стрСообщ)
					return
				if слово.строка == "MODULE":
					счётчик_модуль += 1
					if счётчик_модуль > 1:
						стрСообщ = "MODULE в файле должно быть только один раз!"+ слово.стрИсх
						сам.ош_.Исх("МодульОдин_Проверить()", стрСообщ)
						return

		сам.НачалоМодуль_Проверить()
		if сам.ош_.бВнутр or сам.ош_.бИсх:
			return
		Имя_Проверить()
		if сам.ош_.бВнутр or сам.ош_.бИсх:
			return
		НачалоРазделитель_Проверить()
		if сам.ош_.бВнутр or сам.ош_.бИсх:
			return
		КонецМодуль_Найти()
		if сам.ош_.бВнутр or сам.ош_.бИсх:
			return
		МодульОдин_Проверить()
		if сам.ош_.бВнутр or сам.ош_.бИсх:
			return

	def __НачалоМодуль_Проверить(сам)->None:
		"""
		слово MODULE  в исходнике должен идти первым.
		"""
		слово :тСлово= сам.слова_модуля[0]
		# проверить, что слово является тСлово
		стрМодуль = слово.строка
		if слово.ош.бВнутр:
			сам.ош_.Внутр("__НачалоМодуль_Проверить()", "При проверке слова")
			return
		if стрМодуль != "MODULE":
			стрОш = "В файле отсутствует MODULE" + слово.стрИсх
			сам.ош_.Исх("НачалоМодуль_Проверить()", стрОш)
		сам.__СловаМодуля_Обрезать()
		сам.__бНачалоМодуль_Готово = True

	def Парам_Получ(сам) -> dict:
		парам :dict= {}
		парам['слова'] = сам.слова_модуля
		парам['слова_секции'] = {}
		парам['модуль_имя'] = сам.__имя
		return парам


	def Шаг(сам):
		"""
		Отрабатывает один шаг за раз.
		"""
		if not сам.__бМодульГотов:
			if not сам.__бНачалоМодуль_Готово:
				сам.__НачалоМодуль_Проверить()
				return
			if not

	def Обработать(сам)->None:
		"""
		Выполняет все операции за раз.
		"""
		while not сам.__бМодульГотов:
			сам.Шаг()

	@property
	def имя(сам) -> str:
		return сам.__имя

	@property
	def бМодульГотов(сам):
		"""
		Признак полностью просканированного модуля.
		"""
		return сам.__бМодульГотов

	def __СловаМодуля_Обрезать(сам)->None:
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список :dict= {}
		for ключ in range(1, len(сам.слова_модуля)):
			новый_список[ключ-1]=сам.слова_модуля[ключ]
		сам.слова_модуля :dict= {}
		сам.слова_модуля = новый_список
