# coding: utf8
"""
Модуль предоставляет тип тМодуль.
Содержит процедуры по разбору модуля.

Модуль -- это контейнер с жёсткой структурой.
Обязательно содержит:
1. Заголовок модуля
2. Окончание модуля.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from пакОберон.пакКомпилятор.пакСущность.пакСекция import тСекцияМодуль

class тСканерМодуль(тСекцияМодуль):
	"""
	Тип представляет иерархию модуля с секциями.
	"""
	def __init__(сам, пОберон, пДанные:dict)->None:
		сам.__оберон = пОберон
		сам.__конс = пОберон.конс
		сам.__конс.Отладить("тСканерМодуль.__init__()")

		сам.__бОшВнутр = False
		сам.__бОшИсх = False

		тСекцияМодуль.__init__(сам, пОберон, пДанные)

		сам.__имя :str = "" # Имя текущего модуля
		# содержимое словаря не контролируется
		сам.__бМодульОдин :bool = False # Признак, что MODULE встречается один раз

		#сам.импорт = тИмпорт(сам.слова_модуля)
		сам.__импорт :dict= {} # словари слов импорта
		сам.__конст  :dict= {} # словари слов констант
		сам.__типы   :dict= {} # словари слов типов
		сам.__перем  :dict= {} # словари слов переменных
		сам.__проц   :dict= {} # словари слов процедур
		сам.__начало :dict= {} # словари слов в корне модуля

		сам.__сущн_модули :dict= {} # распознанные сущности импортируемых модулей
		сам.__сущн_конст  :dict= {} # распознанные сущности констант
		сам.__сущн_типы   :dict= {} # распознанные сущности модулей
		сам.__сущн_перем  :dict= {} # распознанные сущности переменных
		сам.__сущн_проц   :dict= {} # распознанные сущности процедур

		сам.__Обработать()

	def __Модуль_Контроль(сам)->None:  # Проверить правильность объявления модуля.
		'''
		Контроль на правильное открытие и закрытие модуля.
		'''
		def НачалоМодуль_Проверить()->None:
			"""
			слово MODULE  в исходнике должен идти первым.
			"""
			слово :тСлово= сам.слова_модуля[0]
			# проверить, что слово является тСлово
			if type(слово) != тСлово:
				сам.__бОшВнутр = True
				стрСообщ = "тСканерМодуль: ошибка компилятора. Слово должно быть тСлово, type="+str(type(слово))
				сам.__конс.ОшВнутр(стрСообщ)
				return
			if слово.строка != "MODULE":
				сам.__бОшИсх = True
				стрСообщ = "тСканерМодуль: ошибка исходника. В файле отсутствует MODULE" + слово.стрИсх
				сам.__конс.Ошибка(стрСообщ)
			сам.__СловаМодуля_Обрезать()
		def Имя_Проверить()->None:
			"""
			Второе слово должно быть правильное имя модуля.
			"""
			слово :тСлово= сам.слова_модуля[0]
			if type(слово) != тСлово:
				сам.__бОшВнутр = True
				стрСообщ =  "тСканерМодуль: ошибка компилятора. Слово должно быть тСлово, type="+str(type(слово))
				сам.__конс.ОшВнутр(стрСообщ)
				return
			if not слово.ЕслиИмя_Строго():
				сам.__бОшИсх = True
				стрСообщ =  "тСканерМодуль: ошибка исходника. Нарушение имени модуля "+слово.стрИсх
				сам.__конс.Ошибка(стрСообщ)
				return
			# запомним имя модуля
			сам.__имя = слово.строка
			сам.__СловаМодуля_Обрезать()

		def НачалоРазделитель_Проверить()->None:
			"""
			Третьим тегом идёт окончание заголовка модуля.
			"""
			слово :тСлово= сам.слова_модуля[0]
			if type(слово) != тСлово:
				сам.__бОшВнутр = True
				стрСообщ =  "тСканерМодуль: ошибка компилятора. Слово должно быть тСлово, type="+str(type(слово))
				сам.__конс.ОшВнутр(стрСообщ)
				return
			if слово.строка != ";":
				сам.__бОшИсх = True
				стрСообщ = "тСканерМодуль: ошибка исходника. Нарушение в окончании имени модуля"+слово.стрИсх
				сам.__конс.Ошибка(стрСообщ)
			сам.__СловаМодуля_Обрезать()

		def КонецМодуль_Найти()->None:
			"""
			Вычисляет окончание модуля.
			"""
			цСчётОбр :int= сам.цСловаМодуля-1
			while цСчётОбр >= 0:
				слово_точка :тСлово= сам.слова_модуля[цСчётОбр]
				стрТочка :str= слово_точка.строка
				if type(слово_точка) != тСлово:
					сам.__бОшВнутр = True
					стрСообщ =  "тСканерМодуль: ошибка компилятора. Слово должно быть тСлово, type="+str(type(слово_точка))
					сам.__конс.Ошибка(стрСообщ)
					return
				# Между ними -- возможно имя модуля
				цСловоКонец = цСчётОбр-2
				if цСловоКонец < 0:
					сам.__бОшВнутр = True
					сам.__конс.ОшВнутр("тСканерМодуль: ошибка компилятора. Выход за пределы словаря слов")
					return
				слово_конец :тСлово= сам.слова_модуля[цСловоКонец]
				стрКонец :str= слово_конец.строка
				if стрТочка == "." and стрКонец == "END":
					слово_имя :тСлово = сам.слова_модуля[цСчётОбр-1]
					стрИмя :str= слово_имя.строка
					if стрИмя == сам.__имя:
						сам.Конец_Уст(сам.слова_модуля[цСчётОбр-2])
						break
					else: # имя модуля в начале и конце -- не совпало
						сам.__бОшИсх = True
						стрСообщ = "тСканерМодуль: ошибка исходника. Имя модуля не совпадает, модуль=\""+сам.__имя + \
									"\" " + слово_имя.стрИсх
						сам.__конс.Ошибка(стрСообщ)
						return
				цСчётОбр -= 1

			if цСчётОбр == -1:
				сам.__бОшИсх = True
				стрСообщ = "тСканерМодуль: Нет окончания модуля "+сам.__имя
				сам.__конс.Ошибка(стрСообщ)
				return

			# теперь отбросим окончание модуля.
			счёт_новый :int= 0
			слова :dict = {}
			# Исключаем концовку модуля (END MyModule.)
			for счёт in range(0, цСчётОбр-2):
				слово = сам.слова_модуля[счёт]
				слова[счёт_новый] = слово
				счёт_новый += 1
			сам.слова_модуля = слова
		def МодульОдин_Проверить():
			# Слово MODULE должно быть одно.
			счётчик_модуль :int= 0
			for номер_тега in сам.слова_модуля:
				слово :тСлово= сам.слова_модуля[номер_тега]
				if type(слово) != тСлово:
					сам.__бОшВнутр = True
					стрСообщ = "тСканерМодуль: ошибка компилятора. Слово должно быть тСлово, type="+type(слово)
					сам.__конс.Ошибка(стрСообщ)
					return
				if слово.строка == "MODULE":
					счётчик_модуль += 1
					if счётчик_модуль > 1:
						сам.__бОшИсх = True
						стрСообщ = "тСканерМодуль: MODULE в файле должно быть только один раз!"+ слово.стрИсх
						сам.__конс.Ошибка(стрСообщ)
						return

		НачалоМодуль_Проверить()
		if сам.__бОшВнутр or сам.__бОшИсх:
			return
		Имя_Проверить()
		if сам.__бОшВнутр or сам.__бОшИсх:
			return
		НачалоРазделитель_Проверить()
		if сам.__бОшВнутр or сам.__бОшИсх:
			return
		КонецМодуль_Найти()
		if сам.__бОшВнутр or сам.__бОшИсх:
			return
		МодульОдин_Проверить()
		if сам.__бОшВнутр or сам.__бОшИсх:
			return

	def Парам_Получ(сам) -> dict:
		парам :dict= {}
		парам['слова'] = сам.слова_модуля
		парам['слова_секции'] = {}
		парам['модуль_имя'] = сам.__имя
		return парам

	def __Обработать(сам)->None:
		сам.__Модуль_Контроль()

	@property
	def имя(сам) -> str:
		return сам.__имя

	def __СловаМодуля_Обрезать(сам)->None:
		"""
		Уменьшает слова секции на 1 с головы.
		"""
		новый_список :dict= {}
		for ключ in range(1, len(сам.слова_модуля)):
			новый_список[ключ-1]=сам.слова_модуля[ключ]
		сам.слова_модуля :dict= {}
		сам.слова_модуля = новый_список

	@property
	def бОшВнутр(сам):
		return сам.__бОшВнутр

	@property
	def бОшИсх(сам):
		return сам.__бОшИсх
