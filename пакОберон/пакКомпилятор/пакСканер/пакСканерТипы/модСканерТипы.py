# coding: utf8
"""
Модуль определяет разбор секции типов.
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from пакОберон.пакКомпилятор.пакСущность.пакСекция import тСекцияТипы

class тСканерТипы(тСекцияТипы):
	def __init__(сам, пОберон, пДанные):
		сам.__оберон = пОберон
		сам.__конс = пОберон.конс
		сам.__конс.Отладить("ТСканерТипы.__init__()")

		сам.__бОшВнутр = False
		сам.__бОшИсх = False

		тСекцияТипы.__init__(сам, пОберон, пДанные)
		if сам.бОшВнутр_СекцияТипы:
			сам.__бОшВнутр = True
			return
		сам.__типы = {} # словарь по словам каждого типа в модуле
		сам.__бТипыПустые = True # По умолчанию секция TYPE пустая
		if сам.__Обработать():
			сам.__бОшИсх = True
			сам.__конс.ОшВнутр("тСканерТипы.__init__(): ошибка компилятора. При сканировании типов")
			return

	def __Обработать(сам):
		"""
		Проводит разбор секции TYPE.
		"""
		if сам.__ЕслиТипыНеПустые():
			сам.__бОшВнутр = True
			сам.__конс.ОшВнутр("тСканерТипы: ошибка компилятора. При сканировании типов")
			return
		else:
			pass # print("Типы не пустые!")
			сам.__ЕслиТипыОграничены()
			сам.СловаСекции_Получить()

	def __ЕслиТипыНеПустые(сам)->bool:
		"""
		Может быть следующее слово:   ; VAR PROCEDURE BEGIN (* END модуля уже отброшено *)
		Секция TYPE может быть пустой, но если есть типы, они должны заканчиваться на ;
		"""
		def Слово_Проверить():
			if type(слово) != тСлово:
				сам.__бОшВнутр = True
				стрОш = "тСканерТипы: ошибка компилятора. Слово должно быть тСлово, type=" + str(type(слово))
				сам.__конс.ОшВнутр(стрОш)
				return

		слово = сам.слова_модуля[0] # первое слово после TYPE, а сам TYPE уже распознан и отброшен
		if Слово_Проверить():
			сам.__бОшВнутр = True
			сам.__конс.ОшВнутр("тСканерТипы: ошибка компилятора. При проверке очередного слова")
			return

		# проверим на внезапный конец секции
		бМаркер = (слово.строка in ["VAR", "PROCEDURE", "BEGIN"])
		if not бМаркер: # секция типизации не пустая
			сам.__бТипыПустые = False
		return сам.__бТипыПустые

	def __ЕслиТипыОграничены(сам):
		"""
		Ищет разделитель окончания типов.
		Сканируем слова все подряд.
		Может быть следующее слово-маркер окончания секции типов: VAR PROCEDURE BEGIN,
		так как типов может быть несколько, то ";" не подходит
		Первое слово всегда должен быть именем типа и не может быть маркером
		Произвольное слово может быть ";" и не может быть маркером
		"""
		def Слово_Проверить():
			if type(слово) != тСлово:
				сам.__бОшВнутр = True
				стрОш = "тСканерТипы: Слово должно быть тСлово, type=" + str(type(слово))
				сам.__конс.ОшВнутр(стрОш)
				return
			# проверяем на предварительно равно -- тогда это не ограничитель
			if слово.строка == "PROCEDURE":
				слово1 = сам.слова_модуля[цСловоСчёт-1]
				if слово1.строка == "=":
					стрПроц = "процедура как тип"
				else:
					стрПроц = "PROCEDURE" # если нет скобки -- точно процедура как блок
			else:
					стрПроц = "вообще не процедура"

			# проверяем на предварительную скобку -- тогда это не ограничитель
			if слово.строка == "VAR":
				слово1 = сам.слова_модуля[цСловоСчёт-1]
				if слово1.строка == "(":
					стрПерем = "параметры процедур-типов"
				else:
					стрПерем = "VAR" # если нет скобки -- точно переменные как блок
			else:
					стрПерем = "вообще не переменные"

			сам.__бМаркер = (слово.строка in [стрПерем, стрПроц, "BEGIN"])

		цСловоСчёт = 0 # первый слово после TYPE, а сам TYPE уже распознали и отбросили
		слово = сам.слова_модуля[цСловоСчёт]
		сам.__бМаркер = False
		Слово_Проверить()
		while  цСловоСчёт < сам.цСловаМодуля - 1:
			if (not сам.__бМаркер):
				цСловоСчёт += 1
				слово = сам.слова_модуля[цСловоСчёт]
				Слово_Проверить()
			else:
				break
		слово = сам.слова_модуля[цСловоСчёт - 1]
		сам.Конец_Уст(слово)
		# Проверка на окончание секции типов
		if слово.строка != ";":
			сам.__бОшИсх = True
			стрОш = "тТипы: ошибка исходника. Слово ограничение секции типов должно быть ';'" + слово.стрИсх
			сам.__конс.Ошибка(стрОш)
			return

	def __Типы_Разделить(сам):
		"""
		Пока не исчерпаны слова секции -- последовательно вызываем новый тип.
		"""
		while len(сам.слова_секции) > 1:
			парам={}
			парам['секция'] = "TYPE"
			парам['слова']  = сам.слова_секции
			парам['имя'] = ""
			парам['бЭкспорт'] = False

			тип = None
			тип = тТип(парам)
			if тип.бОшВнутр:
				сам.__бОшВнутр = True
				сам.__конс.ОшВнутр("тСканерТипы: ошибка компилятора. При получении нового типа")
				return
			сам.__типы[len(сам.__типы)] = тип

			сам.слова_секции = {}
			сам.слова_секции = тип.слова_секции

	def Парам_Получ(сам) -> dict:
		парам = {}
		парам['слова'] = сам.слова_модуля
		парам['слова_секции'] = сам.слова_секции
		return парам

	@property
	def бОшВнутр(сам):
		return сам.__бОшВнутр

	@property
	def бОшИсх(сам):
		return сам.__бОшИсх
