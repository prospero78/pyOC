# coding: utf8
"""
Модуль описывает структуру -- параметр процедуры
"""

if True:
	from пакОберон.пакКомпилятор.пакСущность.пакРод.модРод import тРод
	from пакОберон.пакКомпилятор.пакСущность.пакСлово import тСлово
	from . модПроцБазовая import тПроцБазовая

class тПроцПараметр(тПроцБазовая):
	def __init__(сам, пДанные:dict)->None:
		тПроцБазовая.__init__(сам, пДанные)
		сам.параметры :dict= {} # параметров в поле может быть несколько
		сам.__бСсылка :bool= False # Проверка на VAR в параметрах процедуры
		сам.__предок :str= "" # Предок параметра в параматерах процедуры
		сам.__Ссылка_Проверить()
		сам.__Имя_Проверить()
		while сам.__Запятая_Проверить():
			сам.__Имя_Проверить()
		сам.__Двоеточие_Обрезать()
		сам.__Предок_Проверить()
		сам.__Разделитель_Обрезать()

	def __Разделитель_Обрезать(сам)->None:
		"""
		В простых типах последнее слово ";"
		Поэтому его необходимо обрезать
		"""
		слово_имя :тСлово= сам.слова_секции[0]
		строка_раздел :str= слово_имя.Проверить()
		if строка_раздел == ";":
			сам.СловаСекции_Обрезать()
		elif строка_раздел == ")":
			pass # окончание слов параметров, не надо обрезать
		else:
			assert строка_раздел != ";", "тПроцПараметр: неправильный разделитель поля" + слово_имя.стрИсх

	def __Предок_Проверить(сам)->bool:
		"""
		Проверяет предка параметров процедуры. Должно быть разрешённой строкой.
		Кроме того, имя может быть составным
		"""
		стрОш :str= "тПроцПараметр: тип параметра должно быть допустимым именем, имя="
		бРезульт :bool= False
		слово_имя :тСлово= сам.слова_секции[0]
		имя :str= слово_имя.Проверить()
		assert слово_имя.ЕслиСтр_Допустимо(), стрОш + имя
		предок :str= ""
		цСчёт :int= 0
		while True:
			сам.СловаСекции_Обрезать()
			предок += имя
			слово_имя = сам.слова_секции[цСчёт]
			цСчёт += 1
			имя = слово_имя.Проверить()
			бРезульт = True
			if (имя == ";") or (имя == ")"):
				сам.СловаСекции_Обрезать() # Потому что первого обрезания секции не случится
				break
		assert предок != "", "тПроцПараметр: тип параметра не может быть пустой строкой"
		сам.Предок_Уст(предок)
		return бРезульт

	def __Двоеточие_Обрезать(сам)->None:
		"""
		Здесь может быть только ":"
		"""
		слово_двоеточ :тСлово= сам.слова_секции[0]
		строка_двоеточ :str= слово_двоеточ.Проверить()
		if строка_двоеточ == ":": # есть двоеточие
			сам.СловаСекции_Обрезать()
		else: # а это уже непонятно что
			assert False, "тПроцПараметр: разделитель должен быть ':'" + слово_двоеточ.стрИсх

	def __Запятая_Проверить(сам)->bool:
		"""
		Проверяет не следует ли запятая за именем параметра
		Если их несколько
		"""
		бЗапятая :bool= False
		слово_запятая :тСлово= сам.слова_секции[0]
		запятая :str= слово_запятая.Проверить()
		if запятая == ",":
			сам.СловаСекции_Обрезать()
			бЗапятая = True
		elif запятая == ":":
			pass # это началось описание типа
		else:
			assert False, "тПроцПараметр: допустимая строка ',' или ':'" + слово_запятая.стрИсх
		return бЗапятая

	def __Имя_Проверить(сам)->None:
		"""
		Проверяет имя параметра.
		Имя НЕ МОЖЕТ быть составным
		"""
		слово_имя :тСрока= сам.слова_секции[0]
		имя :str= слово_имя.Проверить()
		assert слово_имя.ЕслиИмя_Строго(), "тПроцПараметр: имя параметра должно быть допустимым именем" + слово_имя.стрИсх
		сам.СловаСекции_Обрезать()
		сам.параметры[len(сам.параметры)] = имя

	def __Ссылка_Проверить(сам)->None:
		"""
		Проверяет является ли параметр ссылочным.
		"""
		слово_ссылка :тСтрока= сам.слова_секции[0]
		строка_ссылка :str= слово_ссылка.Проверить()
		if строка_ссылка == "VAR":
			if сам.__бСсылка == False:
				сам.__бСсылка = True
			else:
				assert False, "тПроцПараметр: ошибчоное повторное присвоение бСсылка"
			сам.СловаСекции_Обрезать()

	def Предок_Уст(сам, пПредок:str)->None:
		"""
		Устанавливает имя с проверкой.
		Разрешаетися устанавливать один раз.
		Процедура с защёлкой.
		"""
		assert type(пПредок) == str, "тТипБазовый: пПредок должен быть str, type=" + str(type(пПредок))
		assert пПредок != "", "тТипБазовый: пПредок не может быть пустым"
		assert сам.__предок == "", "тТипБазовый: имя уже присвоено, имя=" + сам.__предок
		сам.__предок = пПредок

	@property
	def предок(сам)->str:
		return сам.__предок
