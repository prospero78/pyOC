# coding: utf8
"""
Содержит тип для обработки констант.
"""
if True:
	from ....пакСлово import тСлово
	from . модКонстПоле import тКонстПоле
	from ...пакСекция import тСекция

class тКонстанты(тСекция):
	def __init__(сам, пДанные):
		тСекция.__init__(сам, пДанные)
		сам.__бКонстОдин = False # Признак того, что в этом пространстве секций констант больше нет
		сам.__конст = {} # Содержит словарь констант
		сам.__Обработать()

	def ЕслиКонстанты(сам):
		"""
		Первое слово в списке слов должно быть CONST.
		Если нет -- значит в исходнике нет констант.
		"""
		слово = сам.слова_модуля[0]
		if слово.строка =='CONST':
			# укоротить слова
			слова_модуля = {}
			for счёт in range(1, len(сам.слова_модуля)):
				слово = сам.слова_модуля[счёт]
				слова_модуля[счёт-1] = слово
			сам.слова_модуля = {}
			сам.слова_модуля = слова_модуля
			сам.бСекцияЕсть = True
		return сам.бСекцияЕсть

	def ЕслиСекцияНеПусто(сам):
		"""
		Может быть следующее слово:  TYPE VAR PROCEDURE BEGIN
		(* END модуля уже отброшено *)
		"""
		бНеПусто = False # признак что-то есть в секции
		# первый слово после CONST, а сам CONST уже распознан и отброшен
		слово = сам.слова_модуля[0]
		assert type(слово) == тСлово, "тКонст: Слово должно быть тСлово, type="+type(слово)
		# проверим на внезапный конец секции
		бМаркер = not (слово.строка in ["TYPE", "VAR", "PROCEDURE", "BEGIN", "END"])

		if бМаркер: # секция импорта пустая
			бНеПусто = True
		return бНеПусто

	def ЕслиСекцияОграничен(сам):
		"""
		Ищет разделитель окончания констант.
		Сканируем слова все подряд.
		Может быть следующий слово-маркер окончания: TYPE VAR PROCEDURE BEGIN END
		(* END уже отброшено *)
		Последнее слово в секции должно быть ";".
		"""
		цСловаСчёт = 0 # первый слово после CONST, а сам CONST уже распознали и отбросили
		слово = сам.слова_модуля[0]
		ограничитель = ["TYPE", "VAR", "PROCEDURE", "BEGIN", "END"]
		бМаркер = (слово.строка in ограничитель)
		# ищем имя константы
		while (not бМаркер) and (цСловаСчёт < (len(сам.слова_модуля))):
			цСловаСчёт += 1
			слово = сам.слова_модуля[цСловаСчёт]
			assert type(слово) == тСлово, "тКонстанты: Слово должно быть тСлово, type="+type(слово)
			бМаркер = (слово.строка in ограничитель)
		цСловаСчёт -= 1
		слово = сам.слова_модуля[цСловаСчёт]
		сам.слово_конец = слово
		if слово.строка != ";":
			# Константы -- могут занимать весь модуль, без других секций
			сам.ошибка.Печать("тКонстанты: слово должно быть ';', слово="+слово.строка+слово.стрИсх)

	def Константы_Разбить(сам):
		"""
		Теперь слова секции групируем в константы
		"""
		цСчётСлова = 0 # Счётчик констант
		счёт = 0
		while счёт < сам.цСловаВсего:
			парам = {}
			парам['секция'] = "CONST"
			парам['слова'] = сам.слова_секции

			конст = None
			конст = тКонстПоле(парам)
			сам.__конст[len(сам.__конст)] = конст
			сам.слова_секции = {}
			сам.слова_секции = конст.слова_секции

	def __Обработать(сам):
		"""
		Проводит разбор секции CONST.
		"""
		if сам.ЕслиКонстанты():
			if сам.ЕслиСекцияНеПусто():
				#сам.СловаМодуля_Печать()
				сам.ЕслиСекцияОграничен()
				#сам.СловаМодуля_Печать()
				сам.СловаСекции_Получить()
				#сам.СловаСекции_Печать()
				сам.Константы_Разбить()

	@property
	def цСловаВсего(сам):
		return len(сам.слова_секции)
